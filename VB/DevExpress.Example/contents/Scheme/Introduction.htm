<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">
<!-- saved from url=(0049)http://www.scheme.com/tspl3/intro.html -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE--><!-- Edit the .tex version instead--><HTML><HEAD>
<TITLE>Introduction</TITLE>
<META content="text/html; charset=iso-8859-1" http-equiv="Content-Type"><LINK 
rel="stylesheet" type="text/css" href="Introduction_files/tspl.css">
<META name="GENERATOR" content="MSHTML 9.00.8112.16476"></HEAD>
<BODY><A name="g0"></A><A name="./intro:h0"></A><BR>
<I>Concentric rings from a crescent shaped prototile.</I>
<H1>Chapter 1. Introduction<A name="CHPTINTRO"></A></H1>
<P>Scheme is a general-purpose computer programming language. It is a high-level 
language, supporting operations on structured data such as strings, lists, and 
vectors, as well as operations on more traditional data such as numbers and 
characters. While Scheme is often identified with symbolic applications, its 
rich set of data types and flexible control structures make it a truly versatile 
language. Scheme has been employed to write text editors, optimizing compilers, 
operating systems, graphics packages, expert systems, numerical applications, 
financial analysis packages, virtual reality systems, and practically every 
other type of application imaginable. Scheme is a fairly simple language to 
learn, since it is based on a handful of syntactic forms and semantic concepts 
and since the interactive nature of most implementations encourages
 experimentation. Scheme is a challenging language to understand fully, however;
 developing the ability to use its full potential requires careful study and 
practice.
<P>Scheme programs are highly portable across implementations of the same Scheme 
system on different machines, because machine dependencies are almost completely 
hidden from the programmer. Also, because of two related <A 
name="./intro:s0"></A>Scheme standardization efforts, it is possible to write 
programs that are portable across different Scheme implementations. A formal 
ANSI/IEEE standard is described in the "IEEE Standard for the Scheme Programming 
Language"&nbsp;[<A class="citation" href="http://www.scheme.com/tspl3/bibliography.html#g193">13</A>].
 The ANSI/IEEE standard grew out of an ongoing effort by a group of Scheme
 designers, who have published a series of less formal reports, the "<A name="./intro:s1"></A>Revised 
Reports" on Scheme. The most recent, the  "Revised<SUP>5</SUP> Report"&nbsp;[<A 
class="citation" 
href="http://www.scheme.com/tspl3/bibliography.html#g194">14</A>], extends the 
ANSI/IEEE standard in several useful ways.
<P>Although some early Scheme systems were inefficient and slow, many newer 
compiler-based implementations are fast, with programs running on par with 
equivalent programs written in lower-level languages. The relative inefficiency 
that sometimes remains results from run-time checks that support generic 
arithmetic and help programmers detect and correct various common programming 
errors. These checks may be disabled in most implementations.
<P>
<P>Scheme supports many types of data values, or<A 
name="./intro:s2"></A><I>objects</I>, including characters, strings, symbols,
 lists or vectors of objects, and a full set of numeric data types, including 
complex, real, and arbitrary-precision rational numbers.
<P>The storage required to hold the contents of an object is<A 
name="./intro:s3"></A>dynamically allocated as necessary and retained until no 
longer needed, then automatically deallocated, typically by a<A name="./intro:s4"></A><I>garbage 
collector</I> that periodically recovers the storage used by inaccessible 
objects. Simple atomic values, such as small integers, characters, booleans, and 
the empty list, are typically represented as immediate values and thus incur no 
allocation or deallocation overhead.
<P>Regardless of representation, all objects are <A 
name="./intro:s5"></A><I>first-class</I> data values; because they are retained 
indefinitely, they may be passed freely as arguments to procedures, returned as 
values from procedures, and combined to form new objects. This is in contrast 
with many other languages where composite data values such as arrays are either 
statically allocated and never deallocated, allocated on entry to a block of 
code and unconditionally deallocated on exit from the block, or explicitly 
allocated <I>and</I>deallocated by the programmer.
<P>Scheme is a call-by-value language, but for mutable objects (objects that can 
be modified) at least, the values are <A name="./intro:s6"></A>pointers to the 
actual storage. These pointers remain behind the scenes, however, and 
programmers need not be conscious of them except to understand that the storage 
for an object is not copied when an object is passed to or returned from a 
procedure.
<P><A name="./intro:s7"></A>At the heart of the Scheme language is a small core 
of syntactic forms from which all other forms are built. These core forms, a set 
of extended syntactic forms derived from them, and a library of <A name="./intro:s8"></A>primitive 
procedures make up the full Scheme language. An <A 
name="./intro:s9"></A>interpreter or <A name="./intro:s10"></A>compiler for 
Scheme can be quite small and potentially fast and highly reliable. The extended 
syntactic forms and many primitive procedures can be defined in Scheme itself, 
simplifying the implementation and increasing reliability.
<P>Scheme programs share a common printed representation with Scheme data 
structures. As a result, any Scheme program has a natural and obvious internal
 representation as a Scheme object. For example, <A 
name="./intro:s11"></A>variables and syntactic <A 
name="./intro:s12"></A>keywords correspond to symbols, while structured 
syntactic forms correspond to lists. This representation is the basis for the 
syntactic extension facilities provided by Scheme for the definition of new 
syntactic forms in terms of existing syntactic forms and procedures. It also 
facilitates the implementation of interpreters, compilers, and other program 
transformation tools for Scheme directly in Scheme, as well as program 
transformation tools for other languages in Scheme.
<P>
<P>Scheme variables and keywords are<A name="./intro:s13"></A><I>lexically 
scoped</I>, and Scheme programs are<A 
name="./intro:s14"></A><I>block-structured</I>. Identifiers may be bound at top 
level (as are the names of primitive Scheme procedures and syntactic forms) or 
locally, within a given block of code. A local <A name="./intro:s15"></A>binding 
is visible only lexically, i.e., within the program text that makes up the 
particular block of code. An occurrence of an identifier of the same name 
outside this block refers to a different binding; if no binding for the 
identifier exists outside the block, then the reference is invalid. Blocks may 
be nested, and a binding in one block may <A 
name="./intro:s16"></A><I>shadow</I> a binding for an identifier of the same 
name in a surrounding block. The <I>scope</I> of a binding is the block in which 
the bound identifier is visible minus any portions of the block in which the 
identifier is shadowed. Block structure and lexical scoping help create programs 
that are modular, easy to read, easy to maintain, and reliable. Efficient code 
for lexical scoping is possible because a compiler can determine before program 
evaluation the scope of all bindings and the binding to which each identifier 
reference resolves. This does not mean, of course, that a compiler can determine 
the values of all variables, since the actual values are not computed in most 
cases until the program executes.
<P>
<P>In most languages, a <A name="./intro:s17"></A>procedure definition is simply 
the association of a name with a block of code. Certain variables local to the 
block are the parameters of the procedure. In some languages, a procedure 
definition may appear within another block or procedure so long as the procedure 
is invoked only during execution of the enclosing block. In others, procedures 
can be defined only at top level. In Scheme, a procedure definition may appear 
within another block or procedure, and the procedure may be invoked at any time 
thereafter, even if the enclosing block has completed its execution. To support 
<A name="./intro:s18"></A>lexical scoping, a procedure carries the lexical 
context (environment) along with its code.
<P>Furthermore, Scheme procedures are not always named. Instead, procedures are 
<A name="./intro:s19"></A>first-class data objects like strings or numbers, and 
variables are bound to procedures in the same way they are bound to other 
objects.
<P>As with procedures in most other languages, Scheme procedures may be 
recursive. That is, any procedure may invoke itself directly or indirectly. Many 
algorithms are most elegantly or efficiently specified recursively. A special 
case of <A name="./intro:s20"></A>recursion, called <A 
name="./intro:s21"></A>tail recursion, is used to express <A 
name="./intro:s22"></A>iteration, or <A name="./intro:s23"></A>looping. A <A 
name="./intro:s24"></A><I>tail call</I> occurs when one procedure directly 
returns the result of invoking another procedure; <I>tail recursion</I> occurs 
when a procedure recursively tail calls itself, directly or indirectly. Scheme 
implementations are required to implement tail calls as jumps (gotos), so the 
storage overhead normally associated with recursion is avoided. As a result, 
Scheme programmers need master only simple procedure calls and recursion and 
need not be burdened with the usual assortment of looping constructs.
<P>
<P>Scheme supports the definition of arbitrary control structures with<A name="./intro:s25"></A><I>continuations</I>.
 A continuation is a procedure that embodies the remainder of a program at a 
given point in the program. A continuation may be obtained at any time during 
the execution of a program. As with other procedures, a continuation is a 
first-class object and may be invoked at any time after its creation. Whenever 
it is invoked, the program immediately continues from the point where the 
continuation was obtained. Continuations allow the implementation of complex 
control mechanisms including explicit backtracking, multithreading, and 
coroutines.
<P><A name="./intro:s26"></A>Scheme also allows programmers to define new
 syntactic forms in terms of existing syntactic forms using a convenient
 high-level pattern language. Syntactic extensions are useful for defining new 
language constructs, for emulating language constructs found in other languages, 
for achieving the effects of in-line code expansion, and even for emulating 
entire languages in Scheme. Most large Scheme programs are built from a mix of
 syntactic extensions and procedure definitions.
<P>
<P>Scheme evolved from the <A name="./intro:s27"></A>Lisp language and is 
considered to be a dialect of Lisp. Scheme inherited from Lisp the treatment of 
values as first-class objects, several important data types, including symbols 
and lists, and the representation of programs as objects, among other things.
 Lexical scoping and block structure are features taken from<A name="./intro:s28"></A>Algol 
60&nbsp;[<A class="citation" href="http://www.scheme.com/tspl3/bibliography.html#g196">16</A>].
 Scheme was the first Lisp dialect to adopt lexical scoping and block structure, 
the notion of first-class procedures, treatment of tail calls as jumps, and 
continuations.
<P><A name="./intro:s29"></A>Common Lisp&nbsp;[<A class="citation" href="http://www.scheme.com/tspl3/bibliography.html#g199">19</A>] 
and Scheme are both contemporary Lisp languages, and the development of each has 
been influenced by the other. Like Scheme but unlike earlier Lisp languages, 
Common Lisp adopted lexical scoping and first-class procedures, although the
 Common Lisp's syntactic extension facility does not respect lexical scoping.
 Common Lisp's evaluation rules for procedures are different from the evaluation 
rules for other objects, however, and it maintains a separate namespace for 
procedure variables, thereby inhibiting the use of procedures as first-class 
objects. Also, Common Lisp does not support continuations or require proper
 treatment of tail calls, but it does support several less general control 
structures not found in Scheme. While the two languages are similar, Common Lisp 
includes more specialized operators, while Scheme includes more general-purpose 
building blocks out of which such operators (and others) may be built.
<P>
<P>The remainder of this chapter describes Scheme's syntax and naming
 conventions and the typographical conventions used throughout this book.
<P>
<H3><A name="g1"></A><A name="./intro:h1"></A>Section 1.1. Scheme Syntax<A name="SECTINTROSYNTAX"></A></H3>
<P>Scheme programs are made up of keywords, variables, <A 
name="./intro:s30"></A>structured forms, constant data (numbers, characters, 
strings, quoted vectors, quoted lists, quoted symbols, etc.), whitespace, and 
comments.
<P>Keywords, variables, and symbols are collectively called<A 
name="./intro:s31"></A>identifiers. Identifiers may be formed from the following 
set of characters:
<P>
<UL>
  <LI>the lower-case letters <TT>a</TT> through <TT>z</TT>,
  <P></P>
  <LI>the upper-case letters <TT>A</TT> through <TT>Z</TT>,
  <P></P>
  <LI>the digits <TT>0</TT> through <TT>9</TT>, and
  <P></P>
  <LI>the characters 
  <TT>?&nbsp;!&nbsp;.&nbsp;+&nbsp;-&nbsp;*&nbsp;/&nbsp;&lt;&nbsp;=&nbsp;&gt;&nbsp;:&nbsp;$&nbsp;%&nbsp;^&nbsp;&amp;&nbsp;_&nbsp;~&nbsp;@</TT>.
  </LI></UL>
<P>
<P>Identifiers cannot start with an at sign&nbsp;(&nbsp;<TT>@</TT>&nbsp;) and
 normally cannot start with any character that may start a number, i.e., a 
digit, plus sign&nbsp;(&nbsp;<TT>+</TT>&nbsp;), minus 
sign&nbsp;(&nbsp;<TT>-</TT>&nbsp;), or decimal 
point&nbsp;(&nbsp;<TT>.</TT>&nbsp;). Exceptions 
are&nbsp;<TT>+</TT>,&nbsp;<TT>-</TT>, and&nbsp;<TT>...</TT>, which are valid 
identifiers. For example, <TT>hi</TT>, <TT>Hello</TT>, <TT>n</TT>, <TT>x</TT>, 
<TT>x3</TT>, and <TT>?$&amp;*!!!</TT> are all identifiers. Identifiers must be 
delimited by whitespace, parentheses, a string (double) 
quote&nbsp;(&nbsp;<TT>"</TT>&nbsp;), or the comment 
character&nbsp;(&nbsp;<TT>;</TT>&nbsp;). All implementations must recognize as 
identifiers any sequences of characters that adhere to these rules. Other 
sequences of characters, such as <TT>-1234a</TT>, that do not represent numbers 
or other syntactic entities may be recognized as identifiers in some 
implementations, although it is best to avoid such identifiers in code that may 
need to run in more than one Scheme system.
<P>There is no inherent limit on the length of a Scheme identifier; programmers 
may use as many characters as necessary. Long identifiers are no substitute for 
comments, however, and frequent use of long identifiers can make a program 
difficult to format and consequently difficult to read.  
<P>Identifiers may be written in any mix of upper-case and lower-case letters.
 The case is not important, in that two <A name="./intro:s32"></A>identifiers 
differing only in case are identical. For example, <TT>abcde</TT>, 
<TT>Abcde</TT>, <TT>AbCdE</TT>, and <TT>ABCDE</TT>all refer to the same 
identifier. Scheme systems typically print an identifier in either all 
upper-case or all lower-case letters regardless of the way it is entered.
<P>Structured forms and <A name="./intro:s33"></A>list constants are enclosed
 within parentheses, e.g., <TT>(a&nbsp;b&nbsp;c)</TT> or 
<TT>(*&nbsp;(-&nbsp;x&nbsp;2)&nbsp;y)</TT>. The <A name="./intro:s34"></A>empty 
list is written <A name="./intro:s35"></A><TT>()</TT>. Some implementations 
permit the use of<A name="./intro:s36"></A>brackets 
(&nbsp;<TT>[</TT>&nbsp;<TT>]</TT>&nbsp;) in place of parentheses, and brackets 
are sometimes used to set off particular subexpressions for readability.
<P>The <A name="./intro:s37"></A>boolean values representing <A name="./intro:s38"></A><I>true</I> 
and <A name="./intro:s39"></A><I>false</I>are written as <A 
name="./intro:s40"></A><TT>#t</TT> and <A name="./intro:s41"></A><TT>#f</TT>.
 Scheme conditional expressions actually treat <TT>#f</TT> as false and all
 other objects as true, so<TT>3</TT>, <TT>()</TT>, <TT>"false"</TT>, and 
<TT>nil</TT> all count as true.
<P>Vectors are written similarly to lists, except that they are preceded by 
<TT>#(</TT> and terminated by <TT>)</TT>, e.g.,
<TT>#(this&nbsp;is&nbsp;a&nbsp;vector&nbsp;of&nbsp;symbols)</TT>. Strings are 
enclosed in double quotation marks, e.g.,
<TT>"I&nbsp;am&nbsp;a&nbsp;string"</TT>. Characters are preceded by <TT>#\</TT>, 
e.g., <TT>#\a</TT>. Case is important within character and string constants, 
unlike within identifiers. Numbers may be written as integers, e.g., -123, as 
ratios, e.g., 1/2, in floating-point or scientific notation, e.g., 1.3 or 1e23, 
or as complex numbers in rectangular or polar notation, e.g., 1.3-2.7i or 
-1.2@73. Details of the syntax for each type  of constant data are given in the 
individual sections of Chapter&nbsp;<A href="http://www.scheme.com/tspl3/objects.html#g99">6</A> 
and in the formal syntax of Scheme given in the back of the book.
<P>Scheme <A name="./intro:s42"></A>expressions may span several lines, and no 
explicit terminator is required. Since the number of <A 
name="./intro:s43"></A>whitespace characters (spaces and newlines) between 
expressions is not significant, Scheme programs are normally indented to show 
the structure of the code in a way that is pleasing to the author of the 
program.<A name="./intro:s44"></A>Comments may appear on any line of a Scheme 
program, between a <A name="./intro:s45"></A><A name="./intro:s46"></A>semicolon 
(&nbsp;<TT>;</TT>&nbsp;) and the end of the line. Comments explaining a 
particular Scheme expression are normally placed at the same indentation level 
as the expression, on the line before the expression. Comments explaining a 
procedure or group of procedures are normally placed before the procedures, 
without indentation. Multiple comment characters are often used to set off the 
latter kind of comment, e.g., 
<TT>;;;&nbsp;The&nbsp;following&nbsp;procedures&nbsp;...</TT>.
<P>
<H3><A name="g2"></A><A name="./intro:h2"></A>Section 1.2. Scheme Naming 
Conventions<A name="SECTINTRONAMING"></A></H3>
<P>Scheme's <A name="./intro:s47"></A>naming conventions are designed to provide 
a high degree of regularity. The following is a list of these naming 
conventions:
<P>
<UL>
  <LI>Predicate names end in a<A name="./intro:s48"></A><A 
  name="./intro:s49"></A>question mark (&nbsp;<TT>?</TT>&nbsp;). Predicates are 
  procedures that return a true or false answer, such as <TT>eq?</TT>, 
  <TT>zero?</TT>, and <TT>string=?</TT>. The common numeric comparators 
  <TT>=</TT>, <TT>&lt;</TT>, <TT>&gt;</TT>, <TT>&lt;=</TT>, and <TT>&gt;=</TT> 
  are exceptions to this naming convention.
  <P></P>
  <LI>Type <A name="./intro:s50"></A>predicates, such as <TT>pair?</TT>, are 
  created from the name of the type, in this case <TT>pair</TT>, and the 
  question mark.
  <P></P>
  <LI>The names of most character, string, and vector procedures start with the 
  prefix <TT>char-</TT>, <TT>string-</TT>, and<TT>vector-</TT>, e.g., 
  <TT>string-append</TT>. (The names of some list procedures start with 
  <TT>list-</TT>, but most do not.)
  <P></P>
  <LI>The names of procedures that convert an object of one type into an object 
  of another type are written as<A 
  name="./intro:s51"></A><TT><I>type<SUB>1</SUB></I>-&gt;<I>type<SUB>2</SUB></I></TT>,
   e.g., <TT>vector-&gt;list</TT>.
  <P></P>
  <LI>The names of procedures and syntactic forms that cause side effects end 
  with an<A name="./intro:s52"></A><A name="./intro:s53"></A>exclamation point 
  (&nbsp;<TT>!</TT>&nbsp;). These include <TT>set!</TT> and 
  <TT>vector-set!</TT>. Procedures that perform input or output technically 
  cause <A name="./intro:s54"></A>side effects, but their names are exceptions 
  to this rule.</LI></UL>
<P>
<P>Programmers should employ these same conventions in their own code whenever
 possible.
<P>
<H3><A name="g3"></A><A name="./intro:h3"></A>Section 1.3. Typographical and 
Notational Conventions<A name="SECTINTRONOTATION"></A></H3>
<P>Often, the value of a procedure or syntactic form is said to be <A name="./intro:s55"></A><I>unspecified</I>.
 This means that an implementation is free to return any Scheme object as the 
value of the procedure or syntactic form. Do not count on this value being the 
same across implementations, the same across versions of the same 
implementation, or even the same across two uses of the procedure or syntactic 
form. Some Scheme systems routinely use a special object to represent
 unspecified values. Printing of this object is often suppressed by interactive 
Scheme systems, so that the values of expressions returning unspecified values 
 are not printed.
<P><A name="./intro:s56"></A>Scheme expressions usually evaluate to a single 
value, although the multiple values mechanism described in Section&nbsp;<A href="http://www.scheme.com/tspl3/control.html#g97">5.7</A> 
allows an expression to evaluate to zero or more than one value. To simplify the 
presentation, this book usually refers to the result of an expression as a 
single value even if the expression may in fact evaluate to zero or more than 
one value.
<P><A name="./intro:s57"></A>This book sometimes says "it is an error" or "an 
error will be signaled" when describing a circumstance in violation of the rules
 of Scheme. Something that is an error is not valid in Scheme, and the behavior 
of a Scheme implementation in such a case is not specified. A signaled error 
results in the invocation of an implementation-dependent error handler, which 
typically results in an error message being printed and a reset of the 
interactive programming system or entry into a debugging subsystem.
<P>The typographic conventions used in this book are straightforward. All Scheme 
objects are printed in a <TT>typewriter</TT> typeface, just as they are to be 
typed at the keyboard. This includes syntactic keywords, variables, constant
 objects, Scheme expressions, and example programs. An <I>italic</I> typeface is 
used to set off syntax variables in the descriptions of syntactic forms and 
arguments in the descriptions of procedures. Italics are also used to set off 
technical terms the first time they appear. In general, names of syntactic forms 
and procedures are never capitalized, even at the beginning of a sentence. The 
same is true for syntax variables written in italics.
<P>In the description of a syntactic form or procedure, a pattern shows the 
syntactic form or the application of the procedure. The syntax keyword or 
procedure name is given in typewriter font, as are parentheses. The remaining 
pieces of the syntax or arguments are shown in italics, using a name that 
implies the type of expression or argument expected by the syntactic form or 
procedure. Ellipses are used to specify zero or more occurrences of a 
subexpression or argument. For example, <TT>(or&nbsp;<I>exp</I>&nbsp;...)</TT> 
describes the <TT>or</TT>syntactic form, which has zero or more subexpressions, 
and<TT>(member&nbsp;<I>obj</I>&nbsp;<I>list</I>)</TT> describes the 
<TT>member</TT>procedure, which expects two arguments, an object and a list.
<P>
<HR class="copyright" align="left">

<P>R. Kent Dybvig / <it>The Scheme Programming Language, Third Edition</it><BR>
Copyright © 2003 <A class="plain" href="http://mitpress.mit.edu/">The MIT 
Press</A>.  Electronically reproduced by permission.<BR>Illustrations © 2003 <A 
class="plain" href="http://hebert.kitp.ucsb.edu/">Jean-Pierre Hébert</A><BR>
 ISBN 0-262-54148-3 / LOC QA76.73.S34D93 <BR><A class="plain" href="http://mitpress.mit.edu/0262541483">to 
order this book</A> / <A class="plain" href="http://www.scheme.com/tspl3/canned/about.html">about 
this book</A></P>
<P><A class="plain" href="http://www.scheme.com/">http://www.scheme.com/</A></P>
</BODY></HTML>
