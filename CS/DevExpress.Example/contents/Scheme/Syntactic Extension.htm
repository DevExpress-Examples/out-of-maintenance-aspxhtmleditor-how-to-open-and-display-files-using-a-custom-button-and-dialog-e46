<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">
<!-- saved from url=(0051)http://www.scheme.com/tspl3/syntax.html -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE--><!-- Edit the .tex version instead--><HTML><HEAD>
<TITLE>Syntactic Extension</TITLE>
<META content="text/html; charset=iso-8859-1" http-equiv="Content-Type"><LINK 
rel="stylesheet" type="text/css" href="Syntactic%20Extension_files/tspl.css">
<META name="GENERATOR" content="MSHTML 9.00.8112.16476"></HEAD>
<BODY><A name="g113"></A><A name="./syntax:h0"></A><BR>
<I>Four two arm spirals, warped in hyperbolic space.</I>
<H1>Chapter 8. Syntactic Extension<A name="CHPTSYNTAX"></A></H1>
<P><A name="./syntax:s0"></A><A name="./syntax:s1"></A><I>Syntactic 
extensions</I>, or <A name="./syntax:s2"></A><I>macros</I>, are used to simplify 
and regularize repeated patterns in a program, to introduce syntactic forms with
 new evaluation rules, and to perform transformations that help make programs 
more efficient.
<P>A syntactic extension typically takes the form
<TT>(<I>keyword</I>&nbsp;<I>subform</I>&nbsp;...)</TT>, where 
<TT><I>keyword</I></TT> is the identifier that names the syntactic extension.
 The syntax of each <TT><I>subform</I></TT> varies from one syntactic extension 
to another. Syntactic extensions can also take the form of improper lists (or 
even singleton identifiers; see Section&nbsp;<A href="http://www.scheme.com/tspl3/syntax.html#g116">8.3</A>),
 although this is less common.
<P>New syntactic extensions are defined by associating keywords with
 transformation procedures, or <I>transformers</I>. Syntactic extensions are 
defined globally using top-level<A name="./syntax:s3"></A><TT>define-syntax</TT> 
forms or within the scope of particular expressions using<A 
name="./syntax:s4"></A><TT>let-syntax</TT>,<A 
name="./syntax:s5"></A><TT>letrec-syntax</TT>, and <A 
name="./syntax:s6"></A>internal <TT>define-syntax</TT>. Transformers are created 
using<A name="./syntax:s7"></A><TT>syntax-rules</TT> or<A 
name="./syntax:s8"></A><TT>syntax-case</TT>, which allow transformations to be 
specified via pattern matching.
<P>Syntactic extensions are expanded into core forms at the start of evaluation 
(before compilation or interpretation) by a syntax <I>expander</I>. The expander 
is invoked once for each top-level form in a program. If the expander encounters 
a syntactic extension, it invokes the associated transformer to expand the 
syntactic extension, then repeats the expansion process for the form returned by 
the transformer. If the expander encounters a core syntactic form, it 
recursively processes the subforms, if any, and reconstructs the form from the
 expanded subforms. Information about identifier bindings is maintained during 
expansion to enforce lexical scoping for variables and keywords.
<P>The syntactic extension mechanisms described in this chapter are part of the 
"syntax-case" system that has become a de&nbsp;facto standard in the absence of 
a standard full-featured syntactic extension system. A portable implementation 
of the syntax-case system is available at
<I>http://www.scheme.com/syntax-case/</I>. The syntax-case system also supports 
modules and several other features that are described in the<I>Chez Scheme 
User's Guide</I>&nbsp;[<A class="citation" href="http://www.scheme.com/tspl3/bibliography.html#g185">5</A>].
 A description of the motivations behind and implementation of the system can be 
found in the articles "Syntactic Abstraction in Scheme"&nbsp;[<A class="citation" 
href="http://www.scheme.com/tspl3/bibliography.html#g187">7</A>] and "Extending 
the Scope of Syntactic Abstraction"&nbsp;[<A class="citation" href="http://www.scheme.com/tspl3/bibliography.html#g202">22</A>].
<P>The Revised<SUP>5</SUP> Report includes only<TT>let-syntax</TT>, 
<TT>letrec-syntax</TT>, top-level<TT>define-syntax</TT>, and 
<TT>syntax-rules</TT>. The pattern language supported by the Revised<SUP>5</SUP> 
Report version of<TT>syntax-rules</TT> is also more limited, with pattern 
ellipses allowed only at the end of list- or vector-structured patterns. (See 
page&nbsp;<A href="http://www.scheme.com/tspl3/syntax.html#patterns">187</A>.)<A 
name="r5rs-let-syntax"></A>Furthermore, the bodies of <TT>let-syntax</TT> and
<TT>letrec-syntax</TT> are treated like <TT>lambda</TT> bodies, i.e., they open 
up new scopes, which prevents them from being used in contexts where definitions 
are required. (See page&nbsp;<A href="http://www.scheme.com/tspl3/syntax.html#letsyntaximplicitbegin">185</A>.)
 Programmers desiring to write programs that are guaranteed to run to all 
Revised<SUP>5</SUP> Report implementations should stick with the
 Revised<SUP>5</SUP> Report subset and use <TT>let-syntax</TT> and 
<TT>letrec-syntax</TT>in a manner consistent with either interpretation. The 
ANSI/IEEE standard does not include any syntactic extension mechanism.
<P>
<H3><A name="g114"></A><A name="./syntax:h1"></A>Section 8.1. Keyword Bindings<A 
name="SECTSYNTAXDEFINITIONS"></A></H3>
<P>This section describes forms that establish bindings between <A name="./syntax:s9"></A>keywords 
and transformers. Keyword bindings may be established at top level, using 
<TT>define-syntax</TT>, or locally, using <TT>let-syntax</TT>,
<TT>letrec-syntax</TT>, or internal <TT>define-syntax</TT>. Existing keyword 
bindings may be rebound temporarily with<TT>fluid-let-syntax</TT>.
<P><A name="./syntax:s10"></A><BR><SPAN class="formdef"><B>syntax</B>: 
<TT>(define-syntax&nbsp;<I>keyword</I>&nbsp;<I>exp</I>)</TT></SPAN><BR>
<B>returns: </B>unspecified
<P><TT><I>exp</I></TT> must evaluate to a transformer.
<P>The following example defines <TT>let*</TT> as a syntactic extension,
 specifying the transformer with <TT>syntax-rules</TT> (see Section&nbsp;<A 
href="http://www.scheme.com/tspl3/syntax.html#g115">8.2</A>).
<P>
<P><TT>(define-syntax&nbsp;let*<BR>&nbsp;&nbsp; (syntax-rules&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;()&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;(let&nbsp;()&nbsp;e1&nbsp;e2&nbsp;...))<BR>
&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;((i1&nbsp;v1)&nbsp;(i2&nbsp;v2)&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (let&nbsp;((i1&nbsp;v1))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (let*&nbsp;((i2&nbsp;v2)&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)))))</TT>
<P><TT>define-syntax</TT> forms appearing at top level behave similarly to
 top-level variable definitions, and <TT>define-syntax</TT> forms appearing at 
the front of a <TT>lambda</TT> or other body behave similarly to internal 
variable definitions. That is, a binding established by a top-level 
<TT>define-syntax</TT> form is visible globally, whereas one established by an 
internal <TT>define-syntax</TT> form is visible only within the body in which 
the <TT>define-syntax</TT> form appears.
<P>All bindings established by a set of internal definitions, whether keyword or 
variable definitions, are visible within the definitions themselves. For 
example, the expression
<P>
<P><TT>(let&nbsp;()<BR>&nbsp;&nbsp; (define&nbsp;even?<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (or&nbsp;(=&nbsp;x&nbsp;0)&nbsp;(odd?&nbsp;(-&nbsp;x&nbsp;1)))))<BR>
&nbsp;&nbsp; (define-syntax&nbsp;odd?<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (syntax-rules&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;x)&nbsp;(not&nbsp;(even?&nbsp;x)))))<BR>
&nbsp;&nbsp; (even?&nbsp;10))</TT>
<P>is valid and should return <TT>#t</TT>.
<P>The expander processes the initial forms in a <TT>lambda</TT> or other body 
from left to right. If it encounters a variable definition, it records the fact 
that the defined identifier is a variable but defers expansion of the
 right-hand-side expression until after all of the definitions have been 
processed. If it encounters a keyword definition, it expands and evaluates the
 right-hand-side expression and binds the keyword to the resulting transformer.
 If it encounters an expression, it fully expands all deferred right-hand-side 
expressions along with the current and remaining body expressions.
<P>An implication of the left-to-right processing order is that one internal 
definition can affect whether a subsequent form is also a definition. For 
example, the expression
<P>
<P><TT>(let&nbsp;()<BR>&nbsp;&nbsp; (define-syntax&nbsp;bind-to-zero<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (syntax-rules&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;id)&nbsp;(define&nbsp;id&nbsp;0))))<BR>
&nbsp;&nbsp; (bind-to-zero&nbsp;x)<BR>&nbsp;&nbsp; x)</TT>
<P>evaluates to <TT>0</TT>, regardless of any binding for<TT>bind-to-zero</TT> 
that might appear outside of the <TT>let</TT>expression.
<P>A top-level syntactic definition must be established before its first use in 
order for that use to be recognized.
<P><A name="./syntax:s11"></A><BR><SPAN class="formdef"><B>syntax</B>: 
<TT>(let-syntax&nbsp;((<I>keyword</I>&nbsp;<I>exp</I>)&nbsp;...)&nbsp;<I>form<SUB>1</SUB></I>&nbsp;<I>form<SUB>2</SUB></I>&nbsp;...)</TT></SPAN>
<BR><SPAN class="formdef"><B>syntax</B>: 
<TT>(letrec-syntax&nbsp;((<I>keyword</I>&nbsp;<I>exp</I>)&nbsp;...)&nbsp;<I>form<SUB>1</SUB></I>&nbsp;<I>form<SUB>2</SUB></I>&nbsp;...)</TT></SPAN>
<BR><B>returns: </B>see explanation
<P>Each <TT><I>exp</I></TT> must evaluate to a transformer. For both 
<TT>let-syntax</TT> and <TT>letrec-syntax</TT>, each <TT><I>keyword</I></TT>is 
bound within the forms 
<TT><I>form<SUB>1</SUB></I>&nbsp;<I>form<SUB>2</SUB></I>&nbsp;...</TT>. For 
<TT>letrec-syntax</TT> the binding scope also includes each <TT><I>exp</I></TT>.
<P><A name="letsyntaximplicitbegin"></A>A <TT>let-syntax</TT> or 
<TT>letrec-syntax</TT> form may expand into one or more expressions anywhere 
expressions are permitted, in which case the resulting expressions are treated 
as if enclosed in a <TT>begin</TT>expression. This allows a <TT>let-syntax</TT> 
or <TT>letrec-syntax</TT> form to expand into a definition or sequence of 
definitions anywhere definitions are permitted, in which case the definitions 
are treated as if they appeared in place of the <TT>let-syntax</TT> or 
<TT>letrec-syntax</TT> form. (This differs from the Revised<SUP>5</SUP> Report 
treatment of these forms; see page&nbsp;<A href="http://www.scheme.com/tspl3/syntax.html#r5rs-let-syntax">183</A>.)
<P>The following example highlights how <TT>let-syntax</TT>and 
<TT>letrec-syntax</TT> differ.
<P>
<P><TT>(let&nbsp;((f&nbsp;(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;1))))<BR>
&nbsp;&nbsp; (let-syntax&nbsp;((f&nbsp;(syntax-rules&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;x)&nbsp;x)))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (g&nbsp;(syntax-rules&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;x)&nbsp;(f&nbsp;x)))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (list&nbsp;(f&nbsp;1)&nbsp;(g&nbsp;1))))&nbsp;<IMG alt="<graphic>" 
src="Syntactic%20Extension_files/0.gif">&nbsp;(1&nbsp;2)<BR><BR>
(let&nbsp;((f&nbsp;(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;1))))<BR>
&nbsp;&nbsp; (letrec-syntax&nbsp;((f&nbsp;(syntax-rules&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;x)&nbsp;x)))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (g&nbsp;(syntax-rules&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;x)&nbsp;(f&nbsp;x)))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (list&nbsp;(f&nbsp;1)&nbsp;(g&nbsp;1))))&nbsp;<IMG alt="<graphic>" 
src="Syntactic%20Extension_files/0.gif">&nbsp;(1&nbsp;1)</TT>
<P>The two expressions are identical except that the <TT>let-syntax</TT> form in 
the first expression is a <TT>letrec-syntax</TT> form in the second. In the 
first expression, the <TT>f</TT> occurring in <TT>g</TT> refers to the 
<TT>let</TT>-bound variable <TT>f</TT>, whereas in the second it refers to the 
keyword <TT>f</TT> whose binding is established by the<TT>letrec-syntax</TT> 
form.
<P><A name="./syntax:s12"></A><BR><SPAN class="formdef"><B>syntax</B>: 
<TT>(fluid-let-syntax&nbsp;((<I>keyword</I>&nbsp;<I>exp</I>)&nbsp;...)&nbsp;<I>form<SUB>1</SUB></I>&nbsp;<I>form<SUB>2</SUB></I>&nbsp;...)</TT></SPAN>
<BR><B>returns: </B>see explanation
<P>Each <TT><I>exp</I></TT> must evaluate to a transformer.
<TT>fluid-let-syntax</TT> is similar to <TT>let-syntax</TT>, except that instead 
of introducing new bindings for the keywords<TT><I>keyword</I>&nbsp;...</TT>,
<TT>fluid-let-syntax</TT> temporarily alters the existing bindings for the 
keywords during the expansion of its body. That is, during the expansion of 
<TT><I>form<SUB>1</SUB></I>&nbsp;<I>form<SUB>2</SUB></I>&nbsp;...</TT>, the 
visible lexical (or top-level) binding for each <TT>keyword</TT> is temporarily 
replaced by a new association between the keyword and the corresponding 
transformer. This affects any references to the keyword that resolve to the same 
lexical (or top-level) binding whether the references occur in the text of the 
body or are introduced during its expansion. In contrast, <TT>let-syntax</TT> 
captures only those references that occur within the text of its body.
<P>The following example shows how <TT>fluid-let-syntax</TT>differs from 
<TT>let-syntax</TT>.
<P>
<P><TT>(let&nbsp;((f&nbsp;(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;1))))<BR>
&nbsp;&nbsp; (let-syntax&nbsp;((g&nbsp;(syntax-rules&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;x)&nbsp;(f&nbsp;x)))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (let-syntax&nbsp;((f&nbsp;(syntax-rules&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;x)&nbsp;x))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (g&nbsp;1))))&nbsp;<IMG alt="<graphic>" 
src="Syntactic%20Extension_files/0.gif">&nbsp;2<BR><BR>
(let&nbsp;((f&nbsp;(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;1))))<BR>
&nbsp;&nbsp; (let-syntax&nbsp;((g&nbsp;(syntax-rules&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;x)&nbsp;(f&nbsp;x)))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (fluid-let-syntax&nbsp;((f&nbsp;(syntax-rules&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;x)&nbsp;x))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (g&nbsp;1))))&nbsp;<IMG alt="<graphic>" 
src="Syntactic%20Extension_files/0.gif">&nbsp;1</TT>
<P>The two expressions are identical except that the inner<TT>let-syntax</TT> 
form in the first expression is a <TT>fluid-let-syntax</TT> form in the second.
 In the first expression, the <TT>f</TT> occurring in the expansion of
<TT>(g&nbsp;1)</TT> refers to the <TT>let</TT>-bound variable <TT>f</TT>, 
whereas in the second it refers to the keyword <TT>f</TT> by virtue of the fluid 
syntax binding for<TT>f</TT>.
<P>
<H3><A name="g115"></A><A name="./syntax:h2"></A>Section 8.2. Syntax-Rules 
Transformers<A name="SECTSYNTAXRULES"></A></H3>
<P>The <TT>syntax-rules</TT> form described in this section permits simple 
transformers to be specified in a convenient manner. These transformers may be 
bound to keywords using the mechanisms described in Section&nbsp;<A href="http://www.scheme.com/tspl3/syntax.html#g114">8.1</A>.
 While it is much less expressive than the mechanism described in
 Section&nbsp;<A href="http://www.scheme.com/tspl3/syntax.html#g116">8.3</A>, it 
is sufficient for defining many common syntactic extensions.
<P><A name="./syntax:s13"></A><BR><SPAN class="formdef"><B>syntax</B>: 
<TT>(syntax-rules&nbsp;(<I>literal</I>&nbsp;...)&nbsp;<I>clause</I>&nbsp;...)</TT></SPAN>
<BR><B>returns: </B>a transformer
<P>Each <A name="./syntax:s14"></A><TT><I>literal</I></TT> must be an 
identifier. Each clause takes the form:
<P>
<P><TT>(<I>pattern</I>&nbsp;<I>template</I>)</TT>
<P>Each <TT><I>pattern</I></TT> specifies one possible syntax that the input
 form might take, and the corresponding <TT><I>template</I></TT> specifies how 
the output should appear in each case.
<P><A name="./syntax:s15"></A>Patterns consist of list structure, vector 
structure, identifiers, and constants. Each identifier within a pattern is 
either a <TT><I>literal</I></TT>, a <A name="./syntax:s16"></A><I>pattern 
variable</I>, or an<A name="./syntax:s17"></A><A 
name="./syntax:s18"></A><I>ellipsis</I>. The identifier <TT>...</TT> is an 
ellipsis. Any identifier other than <TT>...</TT> is a literal if it appears in 
the list of literals<TT>(<I>literal</I>&nbsp;...)</TT>; otherwise, it is a 
pattern variable. Literals serve as <A name="./syntax:s19"></A>auxiliary 
keywords, such as <TT>else</TT> in<TT>case</TT> and <TT>cond</TT> expressions.
 List and vector structure within a pattern specifies the basic structure
 required of the input, pattern variables specify arbitrary substructure, and 
literals and constants specify atomic pieces that must match exactly. Ellipses 
specify repeated occurrences of the subpatterns they follow.
<P><A name="patterns"></A>An input form <TT><I>F</I></TT> matches a pattern 
<TT><I>P</I></TT> if and only if
<P>
<UL>
  <LI><TT><I>P</I></TT> is a pattern variable,
  <P></P>
  <LI><TT><I>P</I></TT> is a literal identifier and <TT><I>F</I></TT> is an 
  identifier with the same binding (see <TT>free-identifier=?</TT> in
   Section&nbsp;<A href="http://www.scheme.com/tspl3/syntax.html#g116">8.3</A>),
  <P></P>
  <LI><TT><I>P</I></TT> is of the form
  <TT>(<I>P<SUB>1</SUB></I>&nbsp;...&nbsp;<I>P<SUB>n</SUB></I>)</TT>and 
  <TT><I>F</I></TT> is a list of <I>n</I> elements that match 
  <TT><I>P<SUB>1</SUB></I></TT> through<TT><I>P<SUB>n</SUB></I></TT>,
  <P></P>
  <LI><TT><I>P</I></TT> is of the form
  <TT>(<I>P<SUB>1</SUB></I>&nbsp;...&nbsp;<I>P<SUB>n</SUB></I>&nbsp;.&nbsp;<I>P<SUB>x</SUB></I>)</TT>
  and <TT><I>F</I></TT> is a list or improper list of <I>n</I> or more elements
   whose first <I>n</I> elements match <TT><I>P<SUB>1</SUB></I></TT> through 
  <TT><I>P<SUB>n</SUB></I></TT>and whose <I>n</I>th cdr matches 
  <TT><I>P<SUB>x</SUB></I></TT>,
  <P></P>
  <LI><TT><I>P</I></TT> is of the form
  <TT>(<I>P<SUB>1</SUB></I>&nbsp;...&nbsp;<I>P<SUB>k</SUB></I>&nbsp;<I>P<SUB>e</SUB></I>&nbsp;<I>ellipsis</I>&nbsp;<I>P<SUB><I>m</I>+1</SUB></I>&nbsp;...&nbsp;<I>P<SUB>n</SUB></I>)</TT>,
   where <TT><I>ellipsis</I></TT> is the identifier <TT>...</TT>and 
  <TT><I>F</I></TT> is a proper list of <I>n</I>elements whose first <I>k</I> 
  elements match <TT><I>P<SUB>1</SUB></I></TT> through 
  <TT><I>P<SUB>k</SUB></I></TT>, whose next <I>m</I> - <I>k</I> elements each 
  match <TT><I>P<SUB>e</SUB></I></TT>, and whose remaining <I>n</I> - <I>m</I> 
  elements match <TT><I>P<SUB><I>m</I>+1</SUB></I></TT> through 
  <TT><I>P<SUB>n</SUB></I></TT>,
  <P></P>
  <LI><TT><I>P</I></TT> is of the form
  <TT>(<I>P<SUB>1</SUB></I>&nbsp;...&nbsp;<I>P<SUB>k</SUB></I>&nbsp;<I>P<SUB>e</SUB></I>&nbsp;<I>ellipsis</I>&nbsp;<I>P<SUB><I>m</I>+1</SUB></I>&nbsp;...&nbsp;<I>P<SUB>n</SUB></I>&nbsp;.&nbsp;<I>P<SUB>x</SUB></I>)</TT>,
   where <TT><I>ellipsis</I></TT> is the identifier <TT>...</TT>and 
  <TT><I>F</I></TT> is a list or improper list of <I>n</I>elements whose first 
  <I>k</I> elements match <TT><I>P<SUB>1</SUB></I></TT> through 
  <TT><I>P<SUB>k</SUB></I></TT>, whose next <I>m</I> - <I>k</I> elements each 
  match <TT><I>P<SUB>e</SUB></I></TT>, whose next <I>n</I> - <I>m</I> elements 
  match <TT><I>P<SUB><I>m</I>+1</SUB></I></TT> through 
  <TT><I>P<SUB>n</SUB></I></TT>, and  whose <I>n</I>th and final cdr matches 
  <TT><I>P<SUB>x</SUB></I></TT>,
  <P></P>
  <LI><TT><I>P</I></TT> is of the form
  <TT>#(<I>P<SUB>1</SUB></I>&nbsp;...&nbsp;<I>P<SUB>n</SUB></I>)</TT>and 
  <TT><I>F</I></TT> is a vector of <I>n</I> elements that match 
  <TT><I>P<SUB>1</SUB></I></TT> through<TT><I>P<SUB>n</SUB></I></TT>,
  <P></P>
  <LI><TT><I>P</I></TT> is of the form
  <TT>#(<I>P<SUB>1</SUB></I>&nbsp;...&nbsp;<I>P<SUB>k</SUB></I>&nbsp;<I>P<SUB>e</SUB></I>&nbsp;<I>ellipsis</I>&nbsp;<I>P<SUB><I>m</I>+1</SUB></I>&nbsp;...&nbsp;<I>P<SUB>n</SUB></I>)</TT>,
   where <TT><I>ellipsis</I></TT> is the identifier <TT>...</TT>and 
  <TT><I>F</I></TT> is a vector of <I>n</I> or more elements whose first 
  <I>k</I> elements match <TT><I>P<SUB>1</SUB></I></TT> through 
  <TT><I>P<SUB>k</SUB></I></TT>, whose next <I>m</I> - <I>k</I> elements each 
  match <TT><I>P<SUB>e</SUB></I></TT>, and whose remaining <I>n</I> - <I>m</I> 
  elements match <TT><I>P<SUB><I>m</I>+1</SUB></I></TT> through 
  <TT><I>P<SUB>n</SUB></I></TT>, or
  <P></P>
  <LI><TT><I>P</I></TT> is a pattern datum (any nonlist, nonvector, nonsymbol
   object) and <TT><I>F</I></TT> is equal to <TT><I>P</I></TT> in the sense of 
  the<TT>equal?</TT> procedure.</LI></UL>
<P>
<P>The outermost structure of a <TT>syntax-rules</TT> <TT><I>pattern</I></TT>
must actually be in one of the list-structured forms above, although subpatterns 
of the pattern may be in any of the above forms. Furthermore, the first element 
of the outermost pattern is ignored, since it is always assumed to be the 
keyword naming the syntactic form. (These statements do not apply to 
<TT>syntax-case</TT>; see Section&nbsp;<A href="http://www.scheme.com/tspl3/syntax.html#g116">8.3</A>.)
<P>If an input form passed to a <TT>syntax-rules</TT> transformer matches the 
pattern for a given clause, the clause is accepted and the form is transformed 
as specified by the associated template. As this transformation takes place,
 pattern variables appearing in the pattern are bound to the corresponding input 
subforms. Pattern variables appearing within a subpattern followed by one or 
more ellipses may be bound to a set or sets of zero or more input subforms.
<P><A name="./syntax:s20"></A>A template is a pattern variable, an identifier 
that is not a pattern variable, a pattern datum, a list of subtemplates
<TT>(<I>S<SUB>1</SUB></I>&nbsp;...&nbsp;<I>S<SUB>n</SUB></I>)</TT>, an improper 
list of subtemplates
<TT>(<I>S<SUB>1</SUB></I>&nbsp;<I>S<SUB>2</SUB></I>&nbsp;...&nbsp;<I>S<SUB>n</SUB></I>&nbsp;.&nbsp;<I>T</I>)</TT>, 
or a vector of subtemplates 
<TT>#(<I>S<SUB>1</SUB></I>&nbsp;...&nbsp;<I>S<SUB>n</SUB></I>)</TT>. Each 
subtemplate <TT><I>S<SUB>i</SUB></I></TT> is either a template or a template 
followed by one or more ellipses. The final element <TT><I>T</I></TT> of an 
improper subtemplate list is a template.
<P>Pattern variables appearing within a template are replaced in the output by 
the input subforms to which they are bound. Pattern data and identifiers that 
are not pattern variables are inserted directly into the output. List and vector 
structure within the template remains list and vector structure in the output. A 
subtemplate followed by an ellipsis expands into zero or more occurrences of the 
subtemplate. The subtemplate must contain at least one pattern variable from a 
subpattern followed by an ellipsis. (Otherwise, the expander could not determine 
how many times the subform should be repeated in the output.) Pattern variables 
that occur in subpatterns followed by one or more ellipses may occur only in 
subtemplates that are followed by (at least) as many ellipses. These pattern 
variables are replaced in the output by the input subforms to which  they are 
bound, distributed as specified. If a pattern variable is followed by more 
ellipses in the template than in the associated pattern, the input form is 
replicated as necessary.
<P>A template of the form<TT>(...&nbsp;<I>template</I>)</TT> is identical to 
<TT><I>template</I></TT>, except that ellipses within the template have no 
special meaning. That is, any ellipses contained within <TT><I>template</I></TT> 
are treated as ordinary identifiers. In particular, the template 
<TT>(...&nbsp;...)</TT> produces a single ellipsis, <TT>...</TT>. This allows 
syntactic extensions to expand into forms containing ellipses.
<P>
<P>The definition of <TT>or</TT> below demonstrates the use of
<TT>syntax-rules</TT>.
<P>
<P><TT>(define-syntax&nbsp;or<BR>&nbsp;&nbsp; (syntax-rules&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp; ((_)&nbsp;#f)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;e)&nbsp;e)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;e1&nbsp;e2&nbsp;e3&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (let&nbsp;((t&nbsp;e1))&nbsp;(if&nbsp;t&nbsp;t&nbsp;(or&nbsp;e2&nbsp;e3&nbsp;...))))))</TT>
<P>The input patterns specify that the input must consist of the keyword and 
zero or more subexpressions. An <A name="./syntax:s21"></A><A name="./syntax:s22"></A>underscore 
(&nbsp;<TT>_</TT>&nbsp;), which is an ordinary pattern variable, is used by 
convention for the keyword position to remind the programmer and anyone reading 
the definition that the keyword position never fails to contain the expected 
keyword and need not be matched. (In fact, as mentioned above, 
<TT>syntax-rules</TT> ignores what appears in the keyword position.) If more 
than one subexpression is present (third clause), the expanded code both tests 
the value of the first subexpression and returns the value if it is not false.
 To avoid evaluating the expression twice, the transformer introduces a binding 
for the temporary variable <TT>t</TT>.
<P>The expansion algorithm maintains lexical scoping automatically by renaming 
local identifiers as necessary. Thus, the binding for <TT>t</TT> introduced by 
the transformer is visible only within code introduced by the transformer and 
not within subforms of the input. Similarly, the references to the identifiers 
<TT>let</TT> and <TT>if</TT> are unaffected by any bindings present in the 
context of the input.
<P>
<P><TT>(let&nbsp;((if&nbsp;#f))<BR>&nbsp;&nbsp; (let&nbsp;((t&nbsp;'okay))<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (or&nbsp;if&nbsp;t)))&nbsp;<IMG alt="<graphic>" src="Syntactic%20Extension_files/0.gif">&nbsp;okay</TT>
<P>This expression is transformed during expansion to the equivalent of the 
expression below.
<P>
<P><TT>((lambda&nbsp;(if1)<BR>&nbsp;&nbsp;&nbsp; ((lambda&nbsp;(t1)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((lambda&nbsp;(t2)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (if&nbsp;t2&nbsp;t2&nbsp;t1))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if1))<BR>
&nbsp;&nbsp;&nbsp;&nbsp; 'okay))<BR>&nbsp; #f)&nbsp;<IMG alt="<graphic>" src="Syntactic%20Extension_files/0.gif">&nbsp;okay</TT>
<P>In this sample expansion, <TT>if1</TT>, <TT>t1</TT>, and <TT>t2</TT>represent 
identifiers to which <TT>if</TT> and <TT>t</TT> in the original expression and 
<TT>t</TT> in the expansion of <TT>or</TT> have been renamed.
<P>The definition of a simplified version of <TT>cond</TT> below (simplified 
because it requires at least one output expression per clause and  does not 
support the auxiliary keyword <TT>=&gt;</TT>) demonstrates how auxiliary 
keywords such as <TT>else</TT> are recognized in the input to a transformer, via 
inclusion in the list of literals.
<P>
<P><TT>(define-syntax&nbsp;cond<BR>&nbsp;&nbsp; (syntax-rules&nbsp;(else)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;(else&nbsp;e1&nbsp;e2&nbsp;...))&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...))<BR>
&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;(e0&nbsp;e1&nbsp;e2&nbsp;...))&nbsp;(if&nbsp;e0&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...)))<BR>
&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;(e0&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;c1&nbsp;c2&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (if&nbsp;e0&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;(cond&nbsp;c1&nbsp;c2&nbsp;...)))))</TT>
<P>
<H3><A name="g116"></A><A name="./syntax:h3"></A>Section 8.3. Syntax-Case 
Transformers<A name="SECTSYNTAXCASE"></A></H3>
<P>This section describes a more expressive mechanism for creating transformers, 
based on <TT>syntax-case</TT>, a generalized version of<TT>syntax-rules</TT>.
 This mechanism permits more complex transformations to be specified, including 
transformations that "bend" lexical scoping in a controlled manner, allowing a 
much broader class of syntactic extensions to be defined. Any transformer that 
may be defined using <TT>syntax-rules</TT> may be rewritten easily to use 
<TT>syntax-case</TT> instead; in fact, <TT>syntax-rules</TT>itself may be 
defined as a syntactic extension in terms of<TT>syntax-case</TT>, as 
demonstrated within the description of<TT>syntax</TT> below.
<P>With this mechanism, transformers are procedures of one argument. The 
argument is a <I>syntax object</I> representing the form to be processed. The 
return value is a syntax object representing the output form. A syntax object 
contains contextual information about a form in addition to its structure. This 
contextual information is used by the expander to maintain lexical scoping.
<P>A syntax object representing an identifier is itself referred to as an 
identifier; thus, the term <I>identifier</I> may refer either to the syntactic 
entity (symbol, variable, or keyword) or to the concrete representation of the 
syntactic entity as a syntax object. It is rarely necessary to distinguish the 
two uses.
<P>Transformers destructure their input with <TT>syntax-case</TT> and rebuild
 their output with <TT>syntax</TT>. These two forms alone are sufficient for 
defining many syntactic extensions, including any that can be defined using 
<TT>syntax-rules</TT>. They are described below along with a set of additional 
forms and procedures that provide added functionality.
<P><A name="./syntax:s23"></A><BR><SPAN class="formdef"><B>syntax</B>: 
<TT>(syntax-case&nbsp;<I>exp</I>&nbsp;(<I>literal</I>&nbsp;...)&nbsp;<I>clause</I>&nbsp;...)</TT></SPAN>
<BR><B>returns: </B>see below
<P>Each <TT><I>literal</I></TT> must be an identifier. Each 
<TT><I>clause</I></TT> must take one of the following two forms.
<P>
<P><TT>(<I>pattern</I>&nbsp;<I>output-expression</I>)<BR>
(<I>pattern</I>&nbsp;<I>fender</I>&nbsp;<I>output-expression</I>)</TT>
<P><TT>syntax-case</TT> patterns may be in any of the forms described in 
Section&nbsp;<A href="http://www.scheme.com/tspl3/syntax.html#g115">8.2</A>.
<P><TT>syntax-case</TT> first evaluates <TT><I>exp</I></TT>, then attempts to 
match the resulting value against the pattern from the first
<TT><I>clause</I></TT>. This value is usually a syntax object, but it may be any 
Scheme object. If the value matches the pattern and no<A 
name="./syntax:s24"></A><TT><I>fender</I></TT> is present,
<TT><I>output-expression</I></TT> is evaluated and its value returned as the
 value of the <TT>syntax-case</TT> expression. If the value does not match the 
pattern, the value is compared against the next clause, and so on. An error is 
signaled if the value does not match any of the patterns.
<P>If the optional <TT><I>fender</I></TT> is present, it serves as an additional
 constraint on acceptance of a clause. If the value of the <TT>syntax-case</TT> 
<TT><I>exp</I></TT> matches the pattern for a given clause, the corresponding 
<TT><I>fender</I></TT> is evaluated. If <TT><I>fender</I></TT> evaluates to a 
true value, the clause is accepted; otherwise, the clause is rejected as if the 
input had failed to match the pattern. Fenders are logically a part of the 
matching process, i.e., they specify additional matching constraints beyond the 
basic structure of an expression.
<P><A name="./syntax:s25"></A>Pattern variables contained within a clause's
<TT><I>pattern</I></TT> are bound to the corresponding pieces of the input value 
within the clause's <TT><I>fender</I></TT> (if present) and
<TT><I>output-expression</I></TT>. Pattern variables occupy the same name space 
as program variables and keywords; pattern variable bindings created by 
<TT>syntax-case</TT>can shadow (and be shadowed by) program variable and keyword 
bindings as well as other pattern variable bindings. Pattern variables, however, 
can be referenced only within <TT>syntax</TT>expressions.
<P>See the examples following the description of <TT>syntax</TT>.
<P><A name="./syntax:s26"></A><BR><SPAN class="formdef"><B>syntax</B>: 
<TT>(syntax&nbsp;<I>template</I>)</TT></SPAN><BR><B>returns: </B>see below
<P>A <TT>syntax</TT> expression is like a <TT>quote</TT> expression except that 
the values of pattern variables appearing within <TT><I>template</I></TT> are
 inserted into <TT><I>template</I></TT>, and contextual information associated 
both with the input and with the template is retained in the output to support 
lexical scoping. List and vector structures within the template become true 
lists or vectors (suitable for direct application of list or vector operations,
 like <TT>map</TT> or <TT>vector-ref</TT>) to the extent that the list or vector 
structures must be copied to insert the values of pattern variables. A 
<TT>syntax</TT> <TT><I>template</I></TT> is identical to a <TT>syntax-rules</TT>
<TT><I>template</I></TT> and is treated similarly.
<P>The definition of <TT>or</TT> below is equivalent to the one given in
 Section&nbsp;<A href="http://www.scheme.com/tspl3/syntax.html#g115">8.2</A> 
except that it employs <TT>syntax-case</TT> and<TT>syntax</TT> in place of 
<TT>syntax-rules</TT>.
<P>
<P><TT>(define-syntax&nbsp;or<BR>&nbsp;&nbsp; (lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;x&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_)&nbsp;(syntax&nbsp;#f))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;e)&nbsp;(syntax&nbsp;e))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;e1&nbsp;e2&nbsp;e3&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;(let&nbsp;((t&nbsp;e1))&nbsp;(if&nbsp;t&nbsp;t&nbsp;(or&nbsp;e2&nbsp;e3&nbsp;...))))))))</TT>
<P>In this version, the <TT>lambda</TT> expression that produces the transformer 
is explicit, as are the <TT>syntax</TT> forms in the output part of each clause.
 Any <TT>syntax-rules</TT> form can be expressed with<TT>syntax-case</TT> by 
making the <TT>lambda</TT> expression and<TT>syntax</TT> expressions explicit.
 This observation leads to the following definition of<A 
name="./syntax:s27"></A><TT>syntax-rules</TT> in terms of<TT>syntax-case</TT>.
<P>
<P><TT>(define-syntax&nbsp;syntax-rules<BR>&nbsp;&nbsp; (lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;x&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;(i&nbsp;...)&nbsp;((keyword&nbsp;.&nbsp;pattern)&nbsp;template)&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;(lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;x&nbsp;(i&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((dummy&nbsp;.&nbsp;pattern)&nbsp;(syntax&nbsp;template))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...)))))))</TT>
<P>The unreferenced pattern variable <TT>dummy</TT> is used in place of each 
<TT>keyword</TT> since the first position of each <TT>syntax-rules</TT> pattern 
is always ignored.
<P>Since the <TT>lambda</TT> and <TT>syntax</TT> expressions are implicit in a 
<TT>syntax-rules</TT> form, definitions expressed with<TT>syntax-rules</TT> are 
often shorter than the equivalent definitions expressed with 
<TT>syntax-case</TT>. The choice of which to use when either suffices is a 
matter of taste, but many transformers that can be written easily with
<TT>syntax-case</TT> cannot be written easily or at all with 
<TT>syntax-rules</TT>(see Section&nbsp;<A href="http://www.scheme.com/tspl3/syntax.html#g117">8.4</A>).
<P><A name="./syntax:s28"></A><BR><SPAN class="formdef"><B>procedure</B>: 
<TT>(identifier?&nbsp;<I>obj</I>)</TT></SPAN><BR><B>returns: </B><TT>#t</TT> if 
<TT><I>obj</I></TT> is an identifier, <TT>#f</TT> otherwise
<P><TT>identifier?</TT> is often used within <A name="./syntax:s29"></A>fenders 
to verify that certain subforms of an input form are identifiers, as in the
 definition of unnamed <TT>let</TT> below.
<P>
<P><TT>(define-syntax&nbsp;let<BR>&nbsp;&nbsp; (lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (define&nbsp;ids?<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lambda&nbsp;(ls)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (or&nbsp;(null?&nbsp;ls)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (and&nbsp;(identifier?&nbsp;(car&nbsp;ls))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ids?&nbsp;(cdr&nbsp;ls))))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;x&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;((i&nbsp;v)&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ids?&nbsp;(syntax&nbsp;(i&nbsp;...)))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;((lambda&nbsp;(i&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;v&nbsp;...))))))</TT>
<P>Syntactic extensions ordinarily take the form
<TT>(<I>keyword</I>&nbsp;<I>subform</I>&nbsp;...)</TT>, but the
<TT>syntax-case</TT> system permits them to take the form of singleton
 identifiers as well. For example, the keyword <TT>pcar</TT> in the expression 
below may be used both as an identifier (in which case it expands into a call to 
<TT>car</TT>) or as a structured form (in which case it expands into a call to 
<TT>set-car!</TT>).
<P>
<P><TT>(let&nbsp;((p&nbsp;(cons&nbsp;0&nbsp;#f)))<BR>
&nbsp;&nbsp; (define-syntax&nbsp;pcar<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;x&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (_&nbsp;(identifier?&nbsp;x)&nbsp;(syntax&nbsp;(car&nbsp;p)))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;v)&nbsp;(syntax&nbsp;(set-car!&nbsp;p&nbsp;v))))))<BR>
&nbsp;&nbsp; (let&nbsp;((a&nbsp;pcar))<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (pcar&nbsp;1)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (list&nbsp;a&nbsp;pcar)))&nbsp;<IMG alt="<graphic>" 
src="Syntactic%20Extension_files/0.gif">&nbsp;(0&nbsp;1)</TT>
<P>The fender <TT>(identifier?&nbsp;x)</TT> is used to recognize the singleton
 identifier case.
<P><A name="./syntax:s30"></A><BR><SPAN class="formdef"><B>procedure</B>: 
<TT>(free-identifier=?&nbsp;<I>identifier<SUB>1</SUB></I>&nbsp;<I>identifier<SUB>2</SUB></I>)</TT></SPAN>
<BR><SPAN class="formdef"><B>procedure</B>: 
<TT>(bound-identifier=?&nbsp;<I>identifier<SUB>1</SUB></I>&nbsp;<I>identifier<SUB>2</SUB></I>)</TT></SPAN>
<BR><B>returns: </B>see below
<P>Symbolic names alone do not distinguish identifiers unless the identifiers 
are to be used only as symbolic data. The predicates <TT>free-identifier=?</TT> 
and <TT>bound-identifier=?</TT>are used to compare identifiers according to 
their <I>intended use</I>as free references or bound identifiers in a given 
context.
<P><TT>free-identifier=?</TT> is used to determine whether two identifiers would 
be equivalent if they were to appear as free identifiers in the output of a 
transformer. Because identifier references are lexically scoped, this means that 
<TT>(free-identifier=?&nbsp;<I>id<SUB>1</SUB></I>&nbsp;<I>id<SUB>2</SUB></I>)</TT> 
is true if and only if the identifiers <TT><I>id<SUB>1</SUB></I></TT> and 
<TT><I>id<SUB>2</SUB></I></TT> refer to the same lexical or top-level binding.
 (For this comparison, all variables are assumed to have top-level bindings, 
whether defined yet or not.) Literal identifiers (auxiliary keywords) appearing 
in<TT>syntax-case</TT> patterns (such as <TT>else</TT> in <TT>case</TT>and 
<TT>cond</TT>) are matched with <TT>free-identifier=?</TT>.
<P>Similarly, <TT>bound-identifier=?</TT> is used to determine if two 
identifiers would be equivalent if they were to appear as bound identifiers in 
the output of a transformer. In other words, if <TT>bound-identifier=?</TT> 
returns true for two identifiers, a binding for one will capture references to 
the other within its scope. In general, two identifiers are 
<TT>bound-identifier=?</TT> only if both are present in the original program or 
both are introduced by the same transformer application (perhaps 
implicitly---see <TT>datum-&gt;syntax-object</TT>).<TT>bound-identifier=?</TT> 
can be used for detecting duplicate identifiers in a binding construct or for 
other preprocessing of a binding construct that requires detecting instances of 
the bound identifiers.
<P>The definition below is equivalent to the earlier definition of a simplified 
version of <TT>cond</TT> with <TT>syntax-rules</TT>, except that<TT>else</TT> is 
recognized via an explicit call to <TT>free-identifier?</TT> within a fender 
rather than via inclusion in the literals list.
<P>
<P><TT>(define-syntax&nbsp;cond<BR>&nbsp;&nbsp; (lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;x&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;(e0&nbsp;e1&nbsp;e2&nbsp;...))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (and&nbsp;(identifier?&nbsp;(syntax&nbsp;e0))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (free-identifier=?&nbsp;(syntax&nbsp;e0)&nbsp;(syntax&nbsp;else)))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...)))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;(e0&nbsp;e1&nbsp;e2&nbsp;...))&nbsp;(syntax&nbsp;(if&nbsp;e0&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;(e0&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;c1&nbsp;c2&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;(if&nbsp;e0&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;(cond&nbsp;c1&nbsp;c2&nbsp;...)))))))</TT>
<P>With either definition of <TT>cond</TT>, <TT>else</TT> is not recognized as 
an auxiliary keyword if an enclosing lexical binding for <TT>else</TT> exists.
 For example,
<P>
<P><TT>(let&nbsp;((else&nbsp;#f))<BR>
&nbsp;&nbsp; (cond&nbsp;(else&nbsp;(write&nbsp;"oops"))))</TT>
<P>does <I>not</I> write <TT>"oops"</TT>, since <TT>else</TT> is bound lexically 
and is therefore not the same <TT>else</TT> that appears in the definition of
<TT>cond</TT>.
<P>The following definition of unnamed <TT>let</TT>uses 
<TT>bound-identifier=?</TT> to detect duplicate identifiers.
<P>
<P><TT>(define-syntax&nbsp;let<BR>&nbsp;&nbsp; (lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (define&nbsp;ids?<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lambda&nbsp;(ls)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (or&nbsp;(null?&nbsp;ls)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (and&nbsp;(identifier?&nbsp;(car&nbsp;ls))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ids?&nbsp;(cdr&nbsp;ls))))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (define&nbsp;unique-ids?<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lambda&nbsp;(ls)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (or&nbsp;(null?&nbsp;ls)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (and&nbsp;(let&nbsp;notmem?&nbsp;((x&nbsp;(car&nbsp;ls))&nbsp;(ls&nbsp;(cdr&nbsp;ls)))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (or&nbsp;(null?&nbsp;ls)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (and&nbsp;(not&nbsp;(bound-identifier=?&nbsp;x&nbsp;(car&nbsp;ls)))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (notmem?&nbsp;x&nbsp;(cdr&nbsp;ls)))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (unique-ids?&nbsp;(cdr&nbsp;ls))))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;x&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;((i&nbsp;v)&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (and&nbsp;(ids?&nbsp;(syntax&nbsp;(i&nbsp;...)))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (unique-ids?&nbsp;(syntax&nbsp;(i&nbsp;...))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;((lambda&nbsp;(i&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;v&nbsp;...))))))</TT>
<P>With the definition of <TT>let</TT> above, the expression
<P>
<P><TT>(let&nbsp;((a&nbsp;3)&nbsp;(a&nbsp;4))&nbsp;(+&nbsp;a&nbsp;a))</TT>
<P>results in a syntax error, whereas
<P>
<P><TT>(let-syntax&nbsp;((dolet&nbsp;(lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;x&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;b)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;(let&nbsp;((a&nbsp;3)&nbsp;(b&nbsp;4))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (+&nbsp;a&nbsp;b))))))))<BR>
&nbsp;&nbsp; (dolet&nbsp;a))</TT>
<P>evaluates to <TT>7</TT> since the identifier <TT>a</TT> introduced by 
<TT>dolet</TT>and the identifier <TT>a</TT> extracted from the input form are 
not<TT>bound-identifier=?</TT>. Since both occurrences of <TT>a</TT>, however, 
if left as free references, would refer to the same (top-level) binding for 
<TT>a</TT>, <TT>free-identifier=?</TT>would not distinguish them.
<P>Two identifiers that are <TT>free-identifier=?</TT> may not be
<TT>bound-identifier=?</TT>. An identifier introduced by a transformer may refer 
to the same enclosing binding as an identifier not introduced by the 
transformer, but an introduced binding for one will not capture references to 
the other. On the other hand, identifiers that are <TT>bound-identifier=?</TT> 
are<TT>free-identifier=?</TT>, as long as the identifiers have valid bindings in 
the context where they are compared.
<P><A name="./syntax:s31"></A><BR><SPAN class="formdef"><B>syntax</B>: 
<TT>(with-syntax&nbsp;((<I>pattern</I>&nbsp;<I>val</I>)&nbsp;...)&nbsp;<I>exp<SUB>1</SUB></I>&nbsp;<I>exp<SUB>2</SUB></I>&nbsp;...)</TT></SPAN>
<BR><B>returns: </B>the value of the last <TT><I>exp<SUB>i</SUB></I></TT>
<P>It is sometimes useful to construct a transformer's output in separate
 pieces, then put the pieces together.<TT>with-syntax</TT> facilitates this by 
allowing the creation of local pattern bindings.
<P><TT><I>pattern</I></TT> is identical in form to a <TT>syntax-case</TT> 
pattern. The value of each <TT><I>val</I></TT> is computed and destructured 
according to the corresponding <TT><I>pattern</I></TT>, and pattern variables 
within the <TT><I>pattern</I></TT> are bound as with <TT>syntax-case</TT> to 
appropriate portions of the value within 
<TT><I>exp<SUB>1</SUB></I>&nbsp;<I>exp<SUB>2</SUB></I>&nbsp;...</TT>.
<P><TT>with-syntax</TT> may be defined as a syntactic extension in terms of
<TT>syntax-case</TT>.
<P>
<P><TT>(define-syntax&nbsp;with-syntax<BR>&nbsp;&nbsp; (lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;x&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;((p&nbsp;e0)&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;(syntax-case&nbsp;(list&nbsp;e0&nbsp;...)&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((p&nbsp;...)&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...))))))))</TT>
<P>The following definitions of full <A name="./syntax:s32"></A><TT>cond</TT>and 
<A name="./syntax:s33"></A><TT>case</TT>demonstrate the use of 
<TT>with-syntax</TT> to support transformers that employ recursion internally to 
construct their output.
<P>
<P><TT>(define-syntax&nbsp;cond<A name="defn:cond"></A><BR>
&nbsp;&nbsp; (lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;x&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;c1&nbsp;c2&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (let&nbsp;f&nbsp;((c1&nbsp;(syntax&nbsp;c1))&nbsp;(cmore&nbsp;(syntax&nbsp;(c2&nbsp;...))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (if&nbsp;(null?&nbsp;cmore)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;c1&nbsp;(else&nbsp;=&gt;)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((else&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;(syntax&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...)))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((e0)&nbsp;(syntax&nbsp;(let&nbsp;((t&nbsp;e0))&nbsp;(if&nbsp;t&nbsp;t))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((e0&nbsp;=&gt;&nbsp;e1)&nbsp;(syntax&nbsp;(let&nbsp;((t&nbsp;e0))&nbsp;(if&nbsp;t&nbsp;(e1&nbsp;t)))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((e0&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;(syntax&nbsp;(if&nbsp;e0&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...)))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (with-syntax&nbsp;((rest&nbsp;(f&nbsp;(car&nbsp;cmore)&nbsp;(cdr&nbsp;cmore))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;c1&nbsp;(=&gt;)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((e0)&nbsp;(syntax&nbsp;(let&nbsp;((t&nbsp;e0))&nbsp;(if&nbsp;t&nbsp;t&nbsp;rest))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((e0&nbsp;=&gt;&nbsp;e1)&nbsp;(syntax&nbsp;(let&nbsp;((t&nbsp;e0))&nbsp;(if&nbsp;t&nbsp;(e1&nbsp;t)&nbsp;rest))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((e0&nbsp;e1&nbsp;e2&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;(if&nbsp;e0&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;rest)))))))))))</TT>
<P>
<P><TT>(define-syntax&nbsp;case<A name="defn:case"></A><BR>
&nbsp;&nbsp; (lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;x&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;e&nbsp;c1&nbsp;c2&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (with-syntax&nbsp;((body<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (let&nbsp;f&nbsp;((c1&nbsp;(syntax&nbsp;c1))&nbsp;(cmore&nbsp;(syntax&nbsp;(c2&nbsp;...))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (if&nbsp;(null?&nbsp;cmore)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;c1&nbsp;(else)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((else&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;(syntax&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...)))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (((k&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;(if&nbsp;(memv&nbsp;t&nbsp;'(k&nbsp;...))&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...)))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (with-syntax&nbsp;((rest&nbsp;(f&nbsp;(car&nbsp;cmore)&nbsp;(cdr&nbsp;cmore))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;c1&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (((k&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;(if&nbsp;(memv&nbsp;t&nbsp;'(k&nbsp;...))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (begin&nbsp;e1&nbsp;e2&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rest)))))))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;(let&nbsp;((t&nbsp;e))&nbsp;body)))))))</TT>
<P> <A name="./syntax:s34"></A><BR><SPAN class="formdef"><B>procedure</B>: 
<TT>(syntax-object-&gt;datum&nbsp;<I>obj</I>)</TT></SPAN><BR><B>returns: 
</B><TT><I>obj</I></TT> stripped of syntactic information
<P>The procedure <TT>syntax-object-&gt;datum</TT>strips all syntactic 
information from a syntax object and returns the corresponding Scheme "datum."
 Identifiers stripped in this manner are converted to their symbolic names, 
which can then be compared with <TT>eq?</TT>. Thus, a predicate 
<TT>symbolic-identifier=?</TT> might be defined as follows.
<P>
<P><TT>(define&nbsp;symbolic-identifier=?<BR>
&nbsp;&nbsp; (lambda&nbsp;(x&nbsp;y)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (eq?&nbsp;(syntax-object-&gt;datum&nbsp;x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax-object-&gt;datum&nbsp;y))))</TT>
<P>Two identifiers that are <TT>free-identifier=?</TT> are
<TT>symbolic-identifier=?</TT>; in order to refer to the same binding, two 
identifiers must have the same name. The converse is not always true, since two 
identifiers may have the same name but different bindings.
<P><A name="./syntax:s35"></A><BR><SPAN class="formdef"><B>procedure</B>: 
<TT>(datum-&gt;syntax-object&nbsp;<I>template-identifier</I>&nbsp;<I>obj</I>)</TT></SPAN>
<BR><B>returns: </B>a syntax object
<P><TT>datum-&gt;syntax-object</TT> constructs a syntax object from 
<TT><I>obj</I></TT> that contains the same contextual information as
<TT><I>template-identifier</I></TT>, with the effect that the syntax object 
behaves as if it were introduced into the code when
<TT><I>template-identifier</I></TT> was introduced. The template identifier is 
often the keyword of an input form, extracted from the form, and the object is 
often a symbol naming an identifier to be constructed.
<P><TT>datum-&gt;syntax-object</TT> allows a transformer to "bend" lexical
 scoping rules by creating <I>implicit identifiers</I>that behave as if they 
were present in the input form, thus permitting the definition of syntactic
 extensions that introduce visible bindings for or references to identifiers 
that do not appear explicitly in the input form. For example, we can define a <A 
name="./syntax:s36"></A><TT>loop</TT> expression that binds the variable <A 
name="./syntax:s37"></A><TT>break</TT> to an escape procedure within the loop 
body.
<P>
<P><TT>(define-syntax&nbsp;loop<BR>&nbsp;&nbsp; (lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;x&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((k&nbsp;e&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (with-syntax&nbsp;((break&nbsp;(datum-&gt;syntax-object&nbsp;(syntax&nbsp;k)&nbsp;'break)))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;(call-with-current-continuation<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lambda&nbsp;(break)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (let&nbsp;f&nbsp;()&nbsp;e&nbsp;...&nbsp;(f))))))))))
<BR><BR>(let&nbsp;((n&nbsp;3)&nbsp;(ls&nbsp;'()))<BR>&nbsp;&nbsp; (loop<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (if&nbsp;(=&nbsp;n&nbsp;0)&nbsp;(break&nbsp;ls))<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (set!&nbsp;ls&nbsp;(cons&nbsp;'a&nbsp;ls))<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (set!&nbsp;n&nbsp;(-&nbsp;n&nbsp;1))))&nbsp;<IMG alt="<graphic>" 
src="Syntactic%20Extension_files/0.gif">&nbsp;(a&nbsp;a&nbsp;a)</TT>
<P>Were we to define <TT>loop</TT> as
<P>
<P><TT>(define-syntax&nbsp;loop<BR>&nbsp;&nbsp; (lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;x&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;e&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;(call-with-current-continuation<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lambda&nbsp;(break)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (let&nbsp;f&nbsp;()&nbsp;e&nbsp;...&nbsp;(f)))))))))</TT>
<P>the variable <TT>break</TT> would not be visible in <TT>e&nbsp;...</TT>.
<P>It is also useful for <TT><I>obj</I></TT> to represent an arbitrary Scheme 
form, as demonstrated by the following definition of<A 
name="./syntax:s38"></A><TT>include</TT>, an expand-time version of 
<TT>load</TT>.
<P>
<P><TT>(define-syntax&nbsp;include<BR>&nbsp;&nbsp; (lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (define&nbsp;read-file<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lambda&nbsp;(fn&nbsp;k)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (let&nbsp;((p&nbsp;(open-input-file&nbsp;fn)))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (let&nbsp;f&nbsp;((x&nbsp;(read&nbsp;p)))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (if&nbsp;(eof-object?&nbsp;x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (begin&nbsp;(close-input-port&nbsp;p)&nbsp;'())<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (cons&nbsp;(datum-&gt;syntax-object&nbsp;k&nbsp;x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (f&nbsp;(read&nbsp;p))))))))
<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;x&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((k&nbsp;filename)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (let&nbsp;((fn&nbsp;(syntax-object-&gt;datum&nbsp;(syntax&nbsp;filename))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (with-syntax&nbsp;(((exp&nbsp;...)&nbsp;(read-file&nbsp;fn&nbsp;(syntax&nbsp;k))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;(begin&nbsp;exp&nbsp;...))))))))</TT>
<P><TT>(include&nbsp;"filename")</TT> expands into a <TT>begin</TT> expression
 containing the forms found in the file named by<TT>"filename"</TT>. For 
example, if the file <TT>f-def.ss</TT> contains the expression
<TT>(define&nbsp;f&nbsp;(lambda&nbsp;()&nbsp;x))</TT>, the expression
<P>
<P><TT>(let&nbsp;((x&nbsp;"okay"))<BR>&nbsp;&nbsp; (include&nbsp;"f-def.ss")<BR>
&nbsp;&nbsp; (f))</TT>
<P>evaluates to <TT>"okay"</TT>.
<P>The definition of <TT>include</TT> uses <TT>datum-&gt;syntax-object</TT> to 
convert the objects read from the file into syntax objects in the proper lexical 
context, so that identifier references and definitions within those expressions 
are scoped where the <TT>include</TT> form appears.
<P><A name="./syntax:s39"></A><BR><SPAN class="formdef"><B>procedure</B>: 
<TT>(generate-temporaries&nbsp;<I>list</I>)</TT></SPAN><BR><B>returns: </B>a 
list of distinct generated identifiers
<P>Transformers can introduce a fixed number of identifiers into their output by 
naming each identifier. In some cases, however, the number of identifiers to be 
introduced depends upon some characteristic of the input expression. A 
straightforward definition of <TT>letrec</TT>, for example, requires as many
 temporary identifiers as there are binding pairs in the input expression. The 
procedure <TT>generate-temporaries</TT> is used to construct lists of temporary 
identifiers.
<P><TT><I>list</I></TT> may be any list; its contents are not important. The 
number of temporaries generated is the number of elements in 
<TT><I>list</I></TT>. Each temporary is guaranteed to be different from all 
other identifiers.
<P>A definition of <A name="./syntax:s40"></A><TT>letrec</TT> that uses 
<TT>generate-temporaries</TT> is shown below.
<P>
<P><TT>(define-syntax&nbsp;letrec<A name="defn:letrec"></A><BR>
&nbsp;&nbsp; (lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;x&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;((i&nbsp;v)&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (with-syntax&nbsp;(((t&nbsp;...)&nbsp;(generate-temporaries&nbsp;(syntax&nbsp;(i&nbsp;...)))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;(let&nbsp;((i&nbsp;#f)&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (let&nbsp;((t&nbsp;v)&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (set!&nbsp;i&nbsp;t)&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (let&nbsp;()&nbsp;e1&nbsp;e2&nbsp;...)))))))))</TT>
<P>Any transformer that uses <TT>generate-temporaries</TT> in this fashion can
 be rewritten to avoid using it, albeit with a loss of clarity. The trick is to 
use a recursively defined intermediate form that generates one temporary per 
expansion step and completes the expansion after enough temporaries have been 
generated.<A name="fullletvalues"></A>Here is a definition of <A name="./syntax:s41"></A><TT>let-values</TT>
(see page&nbsp;<A 
href="http://www.scheme.com/tspl3/control.html#letvalues">115</A>) that uses 
this technique to support multiple sets of bindings.
<P>
<P><TT>(define-syntax&nbsp;let-values<BR>&nbsp;&nbsp; (syntax-rules&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;()&nbsp;f1&nbsp;f2&nbsp;...)&nbsp;(let&nbsp;()&nbsp;f1&nbsp;f2&nbsp;...))<BR>
&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;((fmls1&nbsp;expr1)&nbsp;(fmls2&nbsp;expr2)&nbsp;...)&nbsp;f1&nbsp;f2&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lvhelp&nbsp;fmls1&nbsp;()&nbsp;()&nbsp;expr1&nbsp;((fmls2&nbsp;expr2)&nbsp;...)&nbsp;(f1&nbsp;f2&nbsp;...)))))
<BR><BR>(define-syntax&nbsp;lvhelp<BR>&nbsp;&nbsp; (syntax-rules&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;(x1&nbsp;.&nbsp;fmls)&nbsp;(x&nbsp;...)&nbsp;(t&nbsp;...)&nbsp;e&nbsp;m&nbsp;b)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lvhelp&nbsp;fmls&nbsp;(x&nbsp;...&nbsp;x1)&nbsp;(t&nbsp;...&nbsp;tmp)&nbsp;e&nbsp;m&nbsp;b))<BR>
&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;()&nbsp;(x&nbsp;...)&nbsp;(t&nbsp;...)&nbsp;e&nbsp;m&nbsp;b)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (call-with-values<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lambda&nbsp;()&nbsp;e)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lambda&nbsp;(t&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (let-values&nbsp;m&nbsp;(let&nbsp;((x&nbsp;t)&nbsp;...)&nbsp;.&nbsp;b)))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;xr&nbsp;(x&nbsp;...)&nbsp;(t&nbsp;...)&nbsp;e&nbsp;m&nbsp;b)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (call-with-values<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lambda&nbsp;()&nbsp;e)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lambda&nbsp;(t&nbsp;...&nbsp;.&nbsp;tmpr)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (let-values&nbsp;m&nbsp;(let&nbsp;((x&nbsp;t)&nbsp;...&nbsp;(xr&nbsp;tmpr))&nbsp;.&nbsp;b)))))))</TT>
<P>The implementation of <TT>lvhelp</TT> is complicated by the need to evaluate 
all of the right-hand-side expressions before creating any of the bindings and 
by the need to support improper formals lists.
<P>A definition of <TT>letrec</TT> that does not use
<TT>generate-temporaries</TT> is left as an exercise for the reader.
<P>
<H3><A name="g117"></A><A name="./syntax:h4"></A>Section 8.4. Examples<A name="SECTSYNTAXEXAMPLES"></A></H3>
<P>This section presents a series of illustrative syntactic extensions defined 
with either <TT>syntax-rules</TT> or <TT>syntax-case</TT>, starting with a few 
simple but useful syntactic extensions and ending with a fairly complex 
mechanism for defining structures with automatically generated constructors, 
predicates, field accessors, and field setters.
<P>The simplest example in this section is the following definition of <A name="./syntax:s42"></A><TT>rec</TT>.
<TT>rec</TT> is a syntactic extension that permits internally recursive
 anonymous (not externally named) procedures to be created with minimal effort.
<P>
<P><TT>(define-syntax&nbsp;rec<BR>&nbsp;&nbsp; (syntax-rules&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;x&nbsp;e)&nbsp;(letrec&nbsp;((x&nbsp;e))&nbsp;x))))
<BR><BR>(map&nbsp;(rec&nbsp;sum<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (if&nbsp;(=&nbsp;x&nbsp;0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (+&nbsp;x&nbsp;(sum&nbsp;(-&nbsp;x&nbsp;1))))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '(0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))&nbsp;<IMG 
alt="<graphic>" 
src="Syntactic%20Extension_files/0.gif">&nbsp;(0&nbsp;1&nbsp;3&nbsp;6&nbsp;10&nbsp;15)</TT>
<P>Using <TT>rec</TT>, we can define the full <TT>let</TT> (both unnamed and 
named) as follows.
<P>
<P><TT>(define-syntax&nbsp;let<BR>&nbsp;&nbsp; (syntax-rules&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;((x&nbsp;v)&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((lambda&nbsp;(x&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;v&nbsp;...))<BR>
&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;f&nbsp;((x&nbsp;v)&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((rec&nbsp;f&nbsp;(lambda&nbsp;(x&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...))&nbsp;v&nbsp;...))))</TT>
<P>Of course, we can also define <TT>let</TT> directly in terms of
<TT>letrec</TT>, although the definition is a bit less clear.
<P>
<P><TT>(define-syntax&nbsp;let<A name="defn:let"></A><BR>
&nbsp;&nbsp; (syntax-rules&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;((x&nbsp;v)&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((lambda&nbsp;(x&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;v&nbsp;...))<BR>
&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;f&nbsp;((x&nbsp;v)&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((letrec&nbsp;((f&nbsp;(lambda&nbsp;(x&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)))&nbsp;f)&nbsp;v&nbsp;...))))</TT>
<P>These definitions rely upon the fact that the first pattern cannot match a 
named <TT>let</TT>, since the first subform of a named<TT>let</TT> must be an 
identifier, not a list of bindings. The following definition uses a fender to 
make this check more robust.
<P>
<P><TT>(define-syntax&nbsp;let<BR>&nbsp;&nbsp; (lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;x&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;((x&nbsp;v)&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;((lambda&nbsp;(x&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;v&nbsp;...)))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;f&nbsp;((x&nbsp;v)&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (identifier?&nbsp;(syntax&nbsp;f))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;((rec&nbsp;f&nbsp;(lambda&nbsp;(x&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...))&nbsp;v&nbsp;...))))))</TT>
<P>Of course, to be completely robust, the <TT>ids?</TT> and <TT>all-ids?</TT> 
checks employed in the definition of unnamed <TT>let</TT> in Section&nbsp;<A 
href="http://www.scheme.com/tspl3/syntax.html#g116">8.3</A>should be employed 
here as well.
<P>
<P>Both variants of <TT>let</TT> are easily described by simple one-line 
patterns, but <TT>do</TT> requires a bit more work. The precise syntax of <A 
name="./syntax:s43"></A><TT>do</TT> cannot be expressed directly with a single 
pattern because some of the bindings in a <TT>do</TT>expression's binding list 
may take the form <TT>(var&nbsp;val)</TT> while others take the form 
<TT>(var&nbsp;val&nbsp;update)</TT>. The following definition of <TT>do</TT> 
uses <TT>syntax-case</TT>internally to parse the bindings separately from the 
overall form.
<P>
<P><TT>(define-syntax&nbsp;do<A name="defn:do"></A><BR>
&nbsp;&nbsp; (lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;x&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;(binding&nbsp;...)&nbsp;(test&nbsp;res&nbsp;...)&nbsp;exp&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (with-syntax&nbsp;((((var&nbsp;val&nbsp;update)&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (map&nbsp;(lambda&nbsp;(b)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;b&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((var&nbsp;val)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;(var&nbsp;val&nbsp;var)))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((var&nbsp;val&nbsp;update)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;(var&nbsp;val&nbsp;update)))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;(binding&nbsp;...)))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;(let&nbsp;doloop&nbsp;((var&nbsp;val)&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (if&nbsp;test<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (begin&nbsp;(if&nbsp;#f&nbsp;#f)&nbsp;res&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (begin&nbsp;exp&nbsp;...&nbsp;(doloop&nbsp;update&nbsp;...))))))))))</TT>
<P>The odd looking expression <TT>(if&nbsp;#f&nbsp;#f)</TT> is inserted before 
the result expressions <TT>res&nbsp;...</TT> in case no result expressions are
 provided, since <TT>begin</TT> requires at least one subexpression. The value 
of <TT>(if&nbsp;#f&nbsp;#f)</TT> is unspecified, which is what we want since the 
value of <TT>do</TT> is unspecified if no result expressions are provided. At 
the expense of a bit more code, we could use <TT>syntax-case</TT> to determine 
whether any result expressions are provided and to produce a loop with either a 
one- or two-armed <TT>if</TT> as appropriate. The resulting expansion would be 
cleaner but semantically equivalent.
<P>
<P>As mentioned in Section&nbsp;<A href="http://www.scheme.com/tspl3/syntax.html#g115">8.2</A>,
 ellipses lose their special meaning within templates of the form 
<TT>(...&nbsp;<I>template</I>)</TT>, This fact allows syntactic extensions to 
expand into syntax definitions containing ellipses. This usage is illustrated by 
the definition below of<A name="./syntax:s44"></A><TT>be-like-begin</TT>.
<P>
<P><TT>(define-syntax&nbsp;be-like-begin<BR>
&nbsp;&nbsp; (syntax-rules&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;name)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (define-syntax&nbsp;name<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax-rules&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;e0&nbsp;e1&nbsp;(...&nbsp;...))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (begin&nbsp;e0&nbsp;e1&nbsp;(...&nbsp;...))))))))</TT>
<P>With <TT>be-like-begin</TT> defined in this manner,
<TT>(be-like-begin&nbsp;sequence)</TT> has the same effect as the following 
definition of <A name="./syntax:s45"></A><TT>sequence</TT>.
<P>
<P><TT>(define-syntax&nbsp;sequence<BR>&nbsp;&nbsp; (syntax-rules&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;e0&nbsp;e1&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (begin&nbsp;e0&nbsp;e1&nbsp;...))))</TT>
<P>That is, a <TT>sequence</TT> form becomes equivalent to a <TT>begin</TT>form 
so that, for example:
<P>
<P><TT>(sequence<BR>&nbsp;&nbsp; (display&nbsp;"Say&nbsp;what?")<BR>
&nbsp;&nbsp; (newline))</TT>
<P>prints "Say what?" followed by a newline.
<P>
<P>The following example shows how one might restrict<TT>if</TT> expressions 
within a given expression to require the "else" (alternative) subexpression by 
defining the local <TT>if</TT> in terms of the top-level <TT>if</TT>.
<P>
<P><TT>(let-syntax&nbsp;((if&nbsp;(lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;x&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;e1&nbsp;e2&nbsp;e3)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;(if&nbsp;e1&nbsp;e2&nbsp;e3)))))))<BR>
&nbsp;&nbsp; (if&nbsp;1&nbsp;2&nbsp;3))&nbsp;<IMG alt="<graphic>" src="Syntactic%20Extension_files/0.gif">&nbsp;2
<BR><BR>(let-syntax&nbsp;((if&nbsp;(lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;x&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;e1&nbsp;e2&nbsp;e3)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;(if&nbsp;e1&nbsp;e2&nbsp;e3)))))))<BR>
&nbsp;&nbsp; (if&nbsp;1&nbsp;2))&nbsp;<IMG alt="<graphic>" src="Syntactic%20Extension_files/0.gif">&nbsp;<I>error</I></TT>
<P>Although this local definition of <TT>if</TT> looks simple enough, there are 
a few subtle ways in which an attempt to write it might go wrong. If <A name="./syntax:s46"></A><TT>letrec-syntax</TT> 
were used in place of <A name="./syntax:s47"></A><TT>let-syntax</TT>, the 
identifier <TT>if</TT> inserted into the  output would refer to the local 
<TT>if</TT>rather than the top-level <TT>if</TT>, and expansion would loop
 indefinitely.
<P>Similarly, if the underscore were replaced with the identifier<TT>if</TT>, 
expansion would again loop indefinitely. The <TT>if</TT> appearing in the 
template <TT>(if&nbsp;e1&nbsp;e2&nbsp;e3)</TT> would be treated as a pattern 
variable bound to the corresponding identifier <TT>if</TT>from the input form, 
which denotes the local version of <TT>if</TT>.
<P>Placing <TT>if</TT> in the list of literals in an attempt to patch up the 
latter version would not work either. This would cause <TT>syntax-case</TT> to 
compare the literal<TT>if</TT> in the pattern, which would be scoped outside the
<TT>let-syntax</TT> expression, with the <TT>if</TT> in the input expression, 
which would be scoped inside the <TT>let-syntax</TT>. Since they would not refer 
to the same binding, they would not be<TT>free-identifier=?</TT>, and a syntax 
error would result.
<P>The conventional use of<A name="./syntax:s48"></A><A 
name="./syntax:s49"></A>underscore (&nbsp;<TT>_</TT>&nbsp;) helps the programmer 
avoid situations like these in which the wrong identifier is matched against or 
inserted by accident.
<P>
<P>It is an error to generate a reference to an identifier that is not present 
within the context of an input form, which can happen if the "closest enclosing 
lexical binding" for an identifier inserted into the output of a transformer 
does not also enclose the input form. For example,
<P>
<P><TT>(let-syntax&nbsp;((divide&nbsp;(lambda&nbsp;(x)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (let&nbsp;((/&nbsp;+))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;x&nbsp;()&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;e1&nbsp;e2)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;(/&nbsp;e1&nbsp;e2))))))))<BR>
&nbsp;&nbsp; (let&nbsp;((/&nbsp;*))&nbsp;(divide&nbsp;2&nbsp;1)))</TT>
<P>results in an error to the effect that&nbsp;<TT>/</TT>&nbsp;is referenced in 
an invalid context, since the occurrence of&nbsp;<TT>/</TT>&nbsp;in the output 
of<TT>divide</TT> is a reference to the variable&nbsp;<TT>/</TT>&nbsp;bound by 
the <TT>let</TT>expression within the transformer.
<P>
<P>As noted in the description of <TT>identifier?</TT> in Section&nbsp;<A href="http://www.scheme.com/tspl3/syntax.html#g116">8.3</A>,
 singleton identifiers can be treated as syntactic extensions and expanded into 
arbitrary forms. Often, it is necessary to treat the case where an identifier 
appears in the first position of a structured expression differently from the 
case where it appears elsewhere, as in the <TT>pcar</TT> example given in the 
description for <TT>identifier?</TT>. In other situations, both cases must or 
may be treated the same. The form <A 
name="./syntax:s50"></A><TT>identifier-syntax</TT>defined below can make doing 
so more convenient<A name="./syntax:s51"></A>.
<P>
<P><TT>(define-syntax&nbsp;identifier-syntax<BR>
&nbsp;&nbsp; (lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;x&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;e)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;x&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (id<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (identifier?&nbsp;(syntax&nbsp;id))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;e))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((id&nbsp;x&nbsp;(...&nbsp;...))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (identifier?&nbsp;(syntax&nbsp;id))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;(e&nbsp;x&nbsp;(...&nbsp;...)))))))))))
<BR><BR>(let&nbsp;((x&nbsp;0))<BR>&nbsp;&nbsp; (define-syntax&nbsp;x++<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (identifier-syntax<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (let&nbsp;((t&nbsp;x))&nbsp;(set!&nbsp;x&nbsp;(+&nbsp;t&nbsp;1))&nbsp;t)))<BR>
&nbsp;&nbsp; (let&nbsp;((a&nbsp;x++))<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (list&nbsp;a&nbsp;x)))&nbsp;<IMG alt="<graphic>" src="Syntactic%20Extension_files/0.gif">&nbsp;(0&nbsp;1)</TT>
<P>
<P>The following example uses<A 
name="./syntax:s52"></A><TT>identifier-syntax</TT>,<A 
name="./syntax:s53"></A><TT>datum-&gt;syntax-object</TT>, and local syntax 
definitions to define a form of <I>method</I>, one of the basic building blocks 
of<A name="./syntax:s54"></A>object-oriented programming (OOP) systems. A <A 
name="./syntax:s55"></A><TT>method</TT> expression is similar to a 
<TT>lambda</TT> expression, except that in addition to the formal parameters and 
body, a <TT>method</TT>expression also contains a list of instance variables 
<TT>(ivar&nbsp;...)</TT>. When a method is invoked, it is always passed an 
<I>object</I>(<I>instance</I>), represented as a vector of <I>fields</I> 
corresponding to the instance variables, and zero or more additional arguments.
 Within the method body, the object is bound implicitly to the identifier 
<TT>self</TT> and the additional arguments are bound to the formal parameters.
 The fields of the object may be accessed or altered within the method body via 
instance variable references or assignments.
<P>
<P><TT>(define-syntax&nbsp;method<A name="defn:method"></A><BR>
&nbsp;&nbsp; (lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;x&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((k&nbsp;(ivar&nbsp;...)&nbsp;formals&nbsp;e1&nbsp;e2&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (with-syntax&nbsp;(((index&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (let&nbsp;f&nbsp;((i&nbsp;0)&nbsp;(ls&nbsp;(syntax&nbsp;(ivar&nbsp;...))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (if&nbsp;(null?&nbsp;ls)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (cons&nbsp;i&nbsp;(f&nbsp;(+&nbsp;i&nbsp;1)&nbsp;(cdr&nbsp;ls))))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (self&nbsp;(datum-&gt;syntax-object&nbsp;(syntax&nbsp;k)&nbsp;'self))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (set!&nbsp;(datum-&gt;syntax-object&nbsp;(syntax&nbsp;k)&nbsp;'set!)))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lambda&nbsp;(self&nbsp;.&nbsp;formals)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (let-syntax&nbsp;((ivar&nbsp;(identifier-syntax<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (vector-ref&nbsp;self&nbsp;index)))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (let-syntax&nbsp;((set!&nbsp;(syntax-rules&nbsp;(ivar&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;ivar&nbsp;e)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (vector-set!&nbsp;self&nbsp;index&nbsp;e))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;x&nbsp;e)&nbsp;(set!&nbsp;x&nbsp;e)))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e1&nbsp;e2&nbsp;...)))))))))</TT>
<P>Local bindings for <TT>ivar&nbsp;...</TT> and for <TT>set!</TT> make the 
fields of the object appear to be ordinary variables, with references and
 assignments translated into calls to <TT>vector-ref</TT> and 
<TT>vector-set!</TT>.<TT>datum-&gt;syntax-object</TT> is used to make the 
introduced bindings of <TT>self</TT> and <TT>set!</TT> visible in the method 
body. Nested <TT>let-syntax</TT> expressions are needed so that the identifiers
<TT>ivar&nbsp;...</TT> serving as auxiliary keywords for the local version of
<TT>set!</TT> are scoped properly. The examples below demonstrate simple uses of 
<TT>method</TT>.
<P>
<P><TT>(let&nbsp;((m&nbsp;(method&nbsp;(a)&nbsp;(x)&nbsp;(list&nbsp;a&nbsp;x&nbsp;self))))<BR>
&nbsp;&nbsp; (m&nbsp;#(1)&nbsp;2))&nbsp;<IMG alt="<graphic>" src="Syntactic%20Extension_files/0.gif">&nbsp;(1&nbsp;2&nbsp;#(1))
<BR><BR>(let&nbsp;((m&nbsp;(method&nbsp;(a)&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (set!&nbsp;a&nbsp;x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (set!&nbsp;x&nbsp;(+&nbsp;a&nbsp;x))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (list&nbsp;a&nbsp;x&nbsp;self))))<BR>
&nbsp;&nbsp; (m&nbsp;#(1)&nbsp;2))&nbsp;<IMG alt="<graphic>" src="Syntactic%20Extension_files/0.gif">&nbsp;(2&nbsp;4&nbsp;#(2))</TT>
<P>In a complete OOP system based on <TT>method</TT>, the instance variables
<TT>ivar&nbsp;...</TT> would likely be drawn from class declarations, not listed 
explicitly in the <TT>method</TT> forms, although the same techniques would be 
used to make instance variables appear as ordinary variables within method 
bodies.
<P>
<P><A name="./syntax:s56"></A>The next example defines a<A 
name="./syntax:s57"></A><TT>define-integrable</TT>form that is similar to 
<TT>define</TT> for procedure definitions except that it causes the code for the 
procedure to be <I>integrated</I>, or inserted, wherever a direct call to the 
procedure is found. No semantic difference is visible between procedures defined 
with<TT>define-integrable</TT> and those defined with <TT>define</TT>, except 
that a top-level <TT>define-integrable</TT> form must appear before the first
 reference to the defined identifier, and syntactic extensions within the body 
of the defined procedure are expanded at the point of call. Lexical scoping is 
preserved, the actual parameters in an integrated call are evaluated once and at 
the proper time, integrable procedures may be used as first-class values, and
 recursive procedures do not cause indefinite recursive expansion.
<P>A <TT>define-integrable</TT> has the following form.
<P>
<P><TT>(define-integrable&nbsp;<I>name</I>&nbsp;<I>lambda-expression</I>)</TT>
<P>A <TT>define-integrable</TT> form expands into a pair of definitions: a 
syntax definition of <TT><I>name</I></TT> and a variable definition of a 
generated name, <TT>residual-<I>name</I></TT>. The transformer for 
<TT><I>name</I></TT> converts apparent calls to<TT><I>name</I></TT> into direct 
calls to <TT><I>lambda-expression</I></TT>. Since the resulting forms are merely 
direct <TT>lambda</TT> applications (the equivalent of <TT>let</TT> 
expressions), the actual parameters are evaluated exactly once and before 
evaluation of the procedure's body, as required. All other references to 
<TT><I>name</I></TT> are replaced with references to
<TT>residual-<I>name</I></TT>. The definition of <TT>residual-<I>name</I></TT> 
binds it to the value of<TT><I>lambda-expression</I></TT>. This allows the 
procedure to be used as a first-class value. Within 
<TT><I>lambda-expression</I></TT>, wherever it appears, <TT><I>name</I></TT>is 
rebound to a transformer that expands all references into references to 
<TT>residual-<I>name</I></TT>. The use of <A 
name="./syntax:s58"></A><TT>fluid-let-syntax</TT>for this purpose prevents 
indefinite expansion from indirect recursion among integrable procedures. This 
allows the procedure to be recursive without causing indefinite expansion.
 Nothing special is done by <TT>define-integrable</TT> to maintain lexical
 scoping, since lexical scoping is maintained automatically by the expander.
<P>
<P><TT>(define-syntax&nbsp;define-integrable<BR>
&nbsp;&nbsp; (lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (define&nbsp;make-residual-name<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lambda&nbsp;(name)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (datum-&gt;syntax-object&nbsp;name<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (string-&gt;symbol<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (string-append&nbsp;"residual-"<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (symbol-&gt;string&nbsp;(syntax-object-&gt;datum&nbsp;name)))))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;x&nbsp;(lambda)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;name&nbsp;(lambda&nbsp;formals&nbsp;form1&nbsp;form2&nbsp;...))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (identifier?&nbsp;(syntax&nbsp;name))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (with-syntax&nbsp;((xname&nbsp;(make-residual-name&nbsp;(syntax&nbsp;name))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (begin<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (define-syntax&nbsp;name<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;x&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (_&nbsp;(identifier?&nbsp;x)&nbsp;(syntax&nbsp;xname))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;arg&nbsp;(...&nbsp;...))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((fluid-let-syntax<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((name&nbsp;(identifier-syntax&nbsp;xname)))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lambda&nbsp;formals&nbsp;form1&nbsp;form2&nbsp;...))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arg&nbsp;(...&nbsp;...)))))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (define&nbsp;xname<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (fluid-let-syntax&nbsp;((name&nbsp;(identifier-syntax&nbsp;xname)))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lambda&nbsp;formals&nbsp;form1&nbsp;form2&nbsp;...))))))))))</TT>
<P>Some Scheme compilers integrate procedures automatically when it is
 appropriate to do so. Compilers cannot normally integrate procedures bound at 
top-level, however, since code that assigns top-level variables can be 
introduced into the system (via <TT>eval</TT> or <TT>load</TT>) at any time.
<TT>define-integrable</TT> can be used to force the integration of procedures 
bound at top-level, even if the integration of locally bound procedures is left 
to the compiler.
<P>
<P><A name="./syntax:s59"></A>The final example of this section defines a simple 
structure definition facility that represents structures as vectors with named 
fields. Structures are defined with<A 
name="./syntax:s60"></A><TT>define-structure</TT>, which takes the form:
<P>
<P><TT>(define-structure&nbsp;<I>name</I>&nbsp;<I>field</I>&nbsp;...)</TT>
<P>where <TT><I>name</I></TT> names the structure and 
<TT><I>field</I>&nbsp;...</TT> names its fields.<TT>define-structure</TT> 
expands into a series of generated definitions: a constructor 
<TT>make-<I>name</I></TT>, a type predicate <TT><I>name</I>?</TT>, and one 
accessor <TT><I>name</I>-<I>field</I></TT> and setter
<TT>set-<I>name</I>-<I>field</I>!</TT> per field name.
<P>
<P><TT>(define-syntax&nbsp;define-structure<BR>&nbsp;&nbsp; (lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (define&nbsp;gen-id<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lambda&nbsp;(template-id&nbsp;.&nbsp;args)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (datum-&gt;syntax-object&nbsp;template-id<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (string-&gt;symbol<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (apply&nbsp;string-append<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (map&nbsp;(lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (if&nbsp;(string?&nbsp;x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (symbol-&gt;string<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax-object-&gt;datum&nbsp;x))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; args))))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case&nbsp;x&nbsp;()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((_&nbsp;name&nbsp;field&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (with-syntax<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((constructor&nbsp;(gen-id&nbsp;(syntax&nbsp;name)&nbsp;"make-"&nbsp;(syntax&nbsp;name)))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (predicate&nbsp;(gen-id&nbsp;(syntax&nbsp;name)&nbsp;(syntax&nbsp;name)&nbsp;"?"))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((access&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (map&nbsp;(lambda&nbsp;(x)&nbsp;(gen-id&nbsp;x&nbsp;(syntax&nbsp;name)&nbsp;"-"&nbsp;x))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;(field&nbsp;...))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((assign&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (map&nbsp;(lambda&nbsp;(x)&nbsp;(gen-id&nbsp;x&nbsp;"set-"&nbsp;(syntax&nbsp;name)&nbsp;"-"&nbsp;x&nbsp;"!"))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;(field&nbsp;...))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (structure-length&nbsp;(+&nbsp;(length&nbsp;(syntax&nbsp;(field&nbsp;...)))&nbsp;1))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((index&nbsp;...)&nbsp;(let&nbsp;f&nbsp;((i&nbsp;1)&nbsp;(ids&nbsp;(syntax&nbsp;(field&nbsp;...))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (if&nbsp;(null?&nbsp;ids)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '()<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (cons&nbsp;i&nbsp;(f&nbsp;(+&nbsp;i&nbsp;1)&nbsp;(cdr&nbsp;ids)))))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax&nbsp;(begin<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (define&nbsp;constructor<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lambda&nbsp;(field&nbsp;...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (vector&nbsp;'name&nbsp;field&nbsp;...)))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (define&nbsp;predicate<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lambda&nbsp;(x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (and&nbsp;(vector?&nbsp;x)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (=&nbsp;(vector-length&nbsp;x)&nbsp;structure-length)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (eq?&nbsp;(vector-ref&nbsp;x&nbsp;0)&nbsp;'name))))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (define&nbsp;access&nbsp;(lambda&nbsp;(x)&nbsp;(vector-ref&nbsp;x&nbsp;index)))&nbsp;...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (define&nbsp;assign<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lambda&nbsp;(x&nbsp;update)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (vector-set!&nbsp;x&nbsp;index&nbsp;update)))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...)))))))</TT>
<P>The constructor accepts as many arguments as there are fields in the
 structure and creates a vector whose first element is the symbol
<TT><I>name</I></TT> and whose remaining elements are the argument values. The 
type predicate returns true if its argument is a vector of the expected length 
whose first element is <TT><I>name</I></TT>.
<P>Since a <TT>define-structure</TT> form expands into a <TT>begin</TT> 
containing definitions, it is itself a definition and can be used wherever
 definitions are valid.
<P>The generated identifiers are created with<A 
name="./syntax:s61"></A><TT>datum-&gt;syntax-object</TT> to allow the 
identifiers to be visible where the <TT>define-structure</TT> form appears.
<P>The examples below demonstrate the use of <TT>define-structure</TT>.
<P>
<P><TT>(define-structure&nbsp;tree&nbsp;left&nbsp;right)<BR>(define&nbsp;t<BR>
&nbsp;&nbsp; (make-tree<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (make-tree&nbsp;0&nbsp;1)<BR>
&nbsp;&nbsp;&nbsp;&nbsp; (make-tree&nbsp;2&nbsp;3)))<BR><BR>t&nbsp;<IMG alt="<graphic>" 
src="Syntactic%20Extension_files/0.gif">&nbsp;#(tree&nbsp;#(tree&nbsp;0&nbsp;1)&nbsp;#(tree&nbsp;2&nbsp;3))<BR>
(tree?&nbsp;t)&nbsp;<IMG alt="<graphic>" 
src="Syntactic%20Extension_files/0.gif">&nbsp;#t<BR>(tree-left&nbsp;t)&nbsp;<IMG 
alt="<graphic>" 
src="Syntactic%20Extension_files/0.gif">&nbsp;#(tree&nbsp;0&nbsp;1)<BR>
(tree-right&nbsp;t)&nbsp;<IMG alt="<graphic>" src="Syntactic%20Extension_files/0.gif">&nbsp;#(tree&nbsp;2&nbsp;3)<BR>
(set-tree-left!&nbsp;t&nbsp;0)<BR>t&nbsp;<IMG alt="<graphic>" src="Syntactic%20Extension_files/0.gif">&nbsp;#(tree&nbsp;0&nbsp;#(tree&nbsp;2&nbsp;3))</TT>
<P>Since the bodies of the generated procedures are short and simple, it may be 
desirable to use <TT>define-integrable</TT> as defined above in place of 
<TT>define</TT> for some or all of the generated procedure definitions.
<P>
<HR class="copyright" align="left">

<P>R. Kent Dybvig / <it>The Scheme Programming Language, Third Edition</it><BR>
Copyright  2003 <A class="plain" href="http://mitpress.mit.edu/">The MIT 
Press</A>.  Electronically reproduced by permission.<BR>Illustrations  2003 <A 
class="plain" href="http://hebert.kitp.ucsb.edu/">Jean-Pierre Hbert</A><BR>ISBN 
0-262-54148-3 / LOC QA76.73.S34D93 <BR><A class="plain" href="http://mitpress.mit.edu/0262541483">to 
order this book</A> / <A class="plain" href="http://www.scheme.com/tspl3/canned/about.html">about 
this book</A></P>
<P><A class="plain" href="http://www.scheme.com/">http://www.scheme.com/</A></P>
</BODY></HTML>
